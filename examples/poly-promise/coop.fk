include std

include map

include helpers_cb

-- Promise interface
interface Promise =
          promise R : Prom R [Promise, RefState, Await, Yield] -> Pid R
        | signal : Sig -> Unit

interface Await [E] =
          await R : Pid R [E|] -> R

interface Tick = tick : Unit

data Prom R = opIntCb {Int -> R} | opStrCb {String -> R}

data Sig = opIntSig Int | opStrSig String

interface Yield = yield : Unit

-- A request to take the current thread and retangle it with the argument.
interface Retwine = retwine : {[Yield]Unit} -> Unit

----------------
-- Pid stuff

data PromiseStatus X = empty | done X | addRes {X -> [Promise, Await, RefState, Yield] Unit}

data Pid X = pid (Ref (PromiseStatus X))

readPid : {Pid X [E|] -> [RefState] PromiseStatus X [E|]}
readPid (pid cell) = read cell

writePid : {Pid X [E|] -> PromiseStatus X [E|] -> [RefState] Unit}
writePid (pid cell) x = write cell x

readPid2 : {Pid X [E|] -> [RefState] (Maybe X)}
readPid2 (pid cell) = case (read cell)
                        { (done x) -> just x
                        | _ -> nothing }

------------
-- Thread code

client : {[Promise[Console], Console, Await[Console], Yield]Unit}
client! = print "Starting!\n";
          let res = promise (opIntCb {x -> print "running "; ouint (x + 10); print " thanks!\n";
                                           promise (opIntCb {x -> print "running "; ouint (x + 15); print " thanks!\n"})} ) in
          yield!;
          -- await res;
          yield!;
          let res3 = promise (opIntCb {x -> print "running "; ouint (x + 20); print " thanks!\n"; unit} ) in
          yield!;
          let res2 = promise (opStrCb {x -> print "stringing  "; print x; print " thanks!\n"; unit} ) in
          yield!;
          -- await res2;
          yield!;
          print "Finished!\n";
          unit

server : {Int -> [Promise[Console], Console, Yield] Unit}
server x = sleep 400000; signal (opIntSig x); yield!;
           sleep 400000; signal (opIntSig x); yield!;
           sleep 400000; signal (opIntSig x); yield!;
           sleep 400000; signal (opStrSig ("yes")); yield!;
           unit

----------------
-- Handler prep

-- Given a pid and a callback, rewrites the callback such that it writes the
-- result to the cell and returns unit, whilst still performing effects as before.
-- Adds RefState to the ambient in the promise.

to_write : {Pid R [E|]-> {S -> [E| Await[E|], Promise[E|], RefState, Yield]R} -> {S -> [E| Await[E|], Promise[E|], RefState, Yield] Unit}}
to_write (pid cell) cb = {x -> case (read cell)
                            { empty -> (write cell (done ((cb x))))
                            | (addRes resumption) -> let res = (cb x) in
                                                     let resump2 = {x -> (resumption x)} in
                                                     resump2 res
                                                        }}

-- -- Converts a function of Int -> Unit to one of Sig -> unit.
prep_int : {{Int -> [E|] Unit} -> {Sig -> [E|] Unit}}
prep_int cb = {s -> case (s)
                    { (opIntSig x) -> cb x
                    | _ -> unit }}

-- as above, for strings.
prep_str : {{String -> [E|] Unit} -> {Sig -> [E|] Unit}}
prep_str cb = {st -> case (st)
                     { (opStrSig st) -> cb st
                     | _ -> unit}}

----------------
-- Handlers

removeAwait : {{[Console, Promise[Console], Await[Console], RefState] Unit} -> [Console, Promise[Console], RefState]Unit}
removeAwait cb = hdlAwait cb!

removeYield : {{[Console, Promise[Console], Await[Console], RefState, Yield]Unit } -> [Console, Promise[Console], Await[Console], RefState] Unit}
removeYield cb = simpleYield cb!

hdl : {Map Sig (List {Sig -> [Console, Promise[Console], Await[Console], RefState, Yield]Unit})  -- Promise storer
    -> <Promise[Console]> Unit      -- client
    -> [Console, RefState] Unit}

----- Installing promises
----- cbMod is the original callback, modified to make its input and return types generic.
hdl cbs <promise (opIntCb cb) -> client> =
    let cell = pid (new empty) in
    -- look at how they massacred my boy!
    let cbMod = prep_int ((to_write cell cb)) in
    hdl (snocOrInsert (opIntSig 0) cbMod cbs) (client cell)

-- ----- same for strings
hdl cbs <promise (opStrCb cb) -> client> =
    let cell = pid (new empty) in
    let cbMod = prep_str ((to_write cell cb)) in
    hdl (snocOrInsert (opStrSig "") cbMod cbs) (client cell)


----- Processing incoming signals without blocked computation.
hdl cbs <signal sig -> client> =
    -- Look to see if there's any promises of this type waiting.
    case (peek sig cbs)
      -- if not, do nothing and return.
      { nothing -> hdl cbs (client unit)
      -- if there is, run it on the client's side and remove it.
      | (just cb) -> hdl (pop sig cbs) (hdlAwait (simpleYield (cb sig)); client unit)}

hdl _ unit = unit

-- Handles awaits, in the easy way.
-- Needs to be fixed at this type; I guess to guarantee that the thunked abilities match?
hdlAwait : {<Await[Console]> Unit -> [Console, Promise[Console], RefState]Unit}

hdlAwait <await cell -> thread> =
    case (<Console, Promise>(readPid cell))
      { (done x) -> hdlAwait (thread x)
      | empty -> (writePid cell (addRes {x -> (<Yield>(thread x))}));
                 unit}
hdlAwait unit = unit


-- Straight away handling the rest of the Yields.
-- This won't work, because the rest of it never gets put back in?
-- hdlAwaitWithYield : {<Await[E|]> Unit -> [E | Yield, Promise[E|], RefState]Unit}
hdlAwaitWithYield : {<Await[Console]> Unit -> [Console,  Yield, Promise[Console], RefState]Unit}

hdlAwaitWithYield <await cell -> thread> =
    print "*- handling await\n";
    case (readPid cell)
      { (done x) -> hdlAwaitWithYield ((thread x))
      -- Just store the whole thing, as before
      | empty -> (writePid cell (addRes {x -> (thread x)}));
      -- | empty -> (writePid cell (addRes {x -> (cut (<Yield(s a -> s a a)>(thread x)))}));
                 unit}


hdlAwaitWithYield unit = unit


----------------------------
-- Sequencing

-- Unary, just resume.
simpleYield : {<Yield> Unit -> Unit}
simpleYield <yield -> k> = simpleYield (k unit)
simpleYield unit = unit

-- Run the first until it's over, then run the second.
seq : {<Yield> Unit -> <Yield> Unit -> Unit}
seq <yield -> k> <m> = seq (k unit) m!
seq unit <yield -> k> = seq (k unit) unit
seq unit <m> = seq m! unit
seq unit unit = unit


-- Twine the two threads together.
twine : {<Yield> Unit -> <Yield> Unit -> [Yield]Unit}
twine <yield -> m> <yield -> n> = yield!; twine (n unit) (m unit)
twine <yield -> m> <n> = yield!; twine n! (m unit)
twine unit <yield -> m> = yield!; twine (m unit) unit
twine unit unit = unit


main : {[Console, RefState] Unit}
main! = simpleYield (hdl mnil (twine (hdlAwaitWithYield (<RefState>(client!)))  (<RefState>(server 10))))
