include std

-- Promise interface
interface Promise [E] =
          promise R : Prom R [E|] -> Pid R
        | signal : Sig -> Unit
        | await R : Pid R -> R

interface Tick = tick : Unit

--------------------------------------
-- This design won't work, as we need to make the type of Pid match the return
-- type of the callback.
--
-- One hack is to always just give an initial value - nothing - which is cast to
-- Maybe R. Then use this to fill the ref cell.

data Prom R [E] = opIntCb {Int -> [E|] R} | opStrCb {String -> [E|] R}

data Sig = opIntSig Int | opStrSig String

data Pid X = pid (Ref (Maybe X))

readPid : {Pid X -> [RefState] (Maybe X)}
readPid (pid cell) = read cell

pr : {Prom Unit [Console]}
pr! = opIntCb {x -> print "running "; ouint (x + 10); print " thanks!\n"; unit}

client : {[Promise [Console], Console]Unit}
client! = print "starting!\n";
          let res = promise (opIntCb {x -> print "running "; ouint (x + 10); print " thanks!\n"; unit} ) in
          let res_str = promise (opStrCb {st -> print "stringing "; print st; print " thanks!\n"}) in
          await res;
          await res_str;
          print "Finished!\n";
          unit

server : {Int -> [Promise, Console, Tick] Unit}
server x = sleep 1000000; tick!; signal (opIntSig x); sleep 1000000; tick!; signal (opStrSig "theeee"); unit-- ; server x

-- Given a pid and a callback, rewrites the callback such that it writes the
-- result to the cell and returns unit, whilst still performing effects as before.
to_write : {Pid R -> {S -> [Console, RefState]R} -> {S -> [Console, RefState] Unit}}
to_write (pid cell) cb = {x -> (write cell (just (cb x)))}


--------------------------------------
-- Handler / scheduler

-- Obviously quite unwieldy due to having loads of promises and that there.

hdl : {List ({String -> [Console, RefState]Unit})    -- String promises.
    -> List ({Int -> [Console, RefState]Unit})    -- Int promises.
    -> Maybe (Pair (Pid R) {R -> [Console, Promise [Console, RefState], RefState] Unit})                  -- possibly suspended client
    -> <Promise [Console, RefState]> Unit      -- client
    -> <Promise, Tick> Unit                -- server
    -> [Console, RefState] Unit}

-- Installing promises.
hdl scbs cbs res <promise (opIntCb cb) -> client> <server> =
    let cell = pid (new nothing) in
    hdl scbs (snoc cbs (<RefState, Console>(to_write cell cb))) res (client cell) (server!)

-- Installing string promises.
hdl scbs cbs res <promise (opStrCb scb) -> client> <server> =
    let cell = pid (new nothing) in
    hdl (snoc scbs (<RefState, Console>(to_write cell scb))) cbs  res (client cell) (server!)

-- Processing incoming signals without blocked computation.
hdl scbs (cb :: cbs) nothing <client> <signal (opIntSig x) -> server> =
    hdl scbs cbs nothing (<Promise> (cb x); client!) (server unit)

-- Processing incoming signals without blocked computation.
hdl (cb :: scbs) cbs  nothing <client> <signal (opStrSig x) -> server> =
    hdl scbs cbs nothing (<Promise> (cb x); client!) (server unit)

-- Processing incoming signals with blocked comp.
hdl scbs (cb :: cbs) (just (pair cell resumption)) unit <signal (opIntSig x) -> server> =
    -- First run the callback.
    let cbResult = cb x in
    -- Then check if the cell has had a value put in it as a result.
    case (readPid cell)
       -- if we have a result, apply whatever the result of the comp is and then resume
       { (just result) -> hdl scbs cbs nothing (cbResult; resumption result) (server unit)
       -- if we do not, just try again
       | nothing -> hdl scbs cbs (just (pair cell resumption)) unit (server unit)}

-- As above, for strings instead.
hdl (cb :: scbs) cbs  (just (pair cell resumption)) unit <signal (opStrSig st) -> server> =
    -- First run the callback.
    let cbResult = cb st in
    -- Then check if the cell has had a value put in it as a result.
    case (readPid cell)
       -- if we have a result, apply whatever the result of the comp is and then resume
       { (just result) -> hdl scbs cbs nothing (cbResult; resumption result) (server unit)
       -- if we do not, just try again
       | nothing -> hdl scbs cbs (just (pair cell resumption)) unit (server unit)}

hdl scbs cbs res <await cell -> client> <server> =
    case (readPid cell)
      { (just x) -> print "straight through\n"; hdl scbs cbs nothing (client x) server!
      | nothing  -> hdl scbs cbs (just (pair cell client)) unit server! }

hdl scbs cbs res <client> <tick -> server> =
    hdl scbs cbs res client! (server unit)


hdl _ _ _ unit _ = unit
hdl _ _ _ _ unit = unit

main : {[Console, RefState] Unit}
main! = hdl [] [] nothing client! (<RefState>(server 10))
