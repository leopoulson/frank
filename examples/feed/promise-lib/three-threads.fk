include std

include map

include helpers_cb

-- Promise interface
interface Promise =
          promise R : Prom R [Promise, RefState] -> Pid R
        | signal : Sig -> Unit
        | await R : Pid R -> R

interface Tick = tick : Unit

data Prom R [E] = nextCb {Unit -> [E|] R}
                | requestCb {Int -> [E|] R}
                | responseCb {Int -> [E|] R}

-- TODO: Change this to be labels; so that it's op S Int?
data Sig = nextSig Unit | requestSig Int | responseSig Int


-- equality between signals
eqSig : {Sig -> Sig -> Bool}
eqSig (requestSig _) (requestSig _) = true
eqSig (responseSig _) (responseSig _) = true
eqSig (nextSig _) (nextSig _) = true
eqSig _ _ = false

data Pid X = pid (Ref (Maybe X))

readPid : {Pid X -> [RefState] (Maybe X)}
readPid (pid cell) = read cell

-- Given a pid and a callback, rewrites the callback such that it writes the
-- result to the cell and returns unit, whilst still performing effects as before.
-- Adds RefState to the ambient in the promise.
to_write : Pid R -> {S -> [E| RefState]R} -> {S -> [E| RefState] Unit}
to_write (pid cell) cb = {x -> let res = (cb x) in
                               write cell (just res)}

-- Converts a function of Int -> Unit to one of Sig -> unit.

prep_next : {{Unit -> [E|]Unit} -> {Sig -> [E|]Unit}}
prep_next cb = {s -> case (s)
                    { (nextSig x) -> cb x
                    | _ -> unit}}

----------------------
-- Thread code
--

next : {[Console, Promise [Console], RefState]Unit}
next! = print "oops!\n"
        ; promise (nextCb {_ -> next!})
        ; unit

client : {[Promise [Console], Console, RefState]Unit}
client! = promise (nextCb
     {_ -> print "oops!\n";
           signal (requestSig 10);
           print "oops2\n";
           client!})
    ; unit

-- server just installs the repsonse promise which reinstalls itself once it's been used.
server : {[Promise]Unit}
server! = promise (requestCb {x -> signal (responseSig (x + 10))}); unit

user : {[Console, Promise [Console]] Unit}
user! = inch!; print "inched\n";
        signal (nextSig unit); user!


-----------------------
-- Handler / scheduler

-- Datatype for the map of signatures to callbacks, etc
-- hdl : {Map Sig (List {Sig -> [Promise [Console], Console, RefState]Unit})  -- callbacks
-- The integer in the pair is the 'index' of the callback, i.e. which thread it was issued on.
data Callbacks [E] = callbacks (Map Sig (List (Pair Int {Sig -> [E|]Unit})))

maybeApply : {Int -> Int -> {[E|]Unit} -> {[E|]R} -> {[E|]R}}
maybeApply cbId threadId callback thread =
    if (cbId == threadId)
     {{callback!; thread!}}
     {thread}

hdl : {Callbacks [Promise [Console], Console, RefState]  --callbacks, parametrised by effects
    -> <Promise [Console]> Unit      -- client
    -> <Promise [Console]> Unit -- user
    -- -> <Promise> Unit -- user
    -> [Console, RefState] Unit}

-- Installing promises
-- cbMod is the original callback, modified to make its input and return types generic.
hdl cbs <promise (nextCb cb) -> client> <user> =
    print "installing\n";
    let cell = pid (new nothing) in
    let cbMod = (prep_next (to_write cell cb)) in
    hdl (snocOrInsert (nextSig unit) (pair 0 cbMod) cbs) (client cell) user!;
    unit

hdl cbs <signal sig -> client> <user> =
    -- Look to see if there's any promises of this type waiting.
    case (peek sig cbs)
      -- if not, do nothing and return.
      { nothing -> hdl cbs (client unit) user!
      -- if there is, run it on the client's side and remove it.
      -- | (just cb) -> hdl (pop sig cbs) ((cb sig); client!) (user unit)}
      -- | (just cb) -> hdl (pop sig cbs) (client unit) ((cb sig); user!)}
      | (just (pair id cb)) -> hdl (pop sig cbs)
                                   ((maybeApply id 0 {cb sig} {client unit})!)
                                   ((maybeApply id 1 {cb sig} user)!)}

-- Processing incoming signals without blocked computation.
hdl cbs <client> <signal sig -> user> =
    -- Look to see if there's any promises of this type waiting.
    case (peek sig cbs)
      -- if not, do nothing and return.
      { nothing -> hdl cbs client! (user unit)
      -- if there is, run it on the client's side and remove it.
      -- | (just (pair id cb)) -> hdl (pop sig cbs) ((cb sig); client!) (user unit)}
      | (just (pair id cb)) -> hdl (pop sig cbs)
                                   ((maybeApply id 0 {cb sig} client)!)
                                   ((maybeApply id 1 {cb sig} {user unit})!)}
                                   -- (user unit)}


-- -- Processing incoming signals with blocked comp.
-- hdl cbs (just (pair cell resumption)) unit <signal sig -> server> =
--     -- If there's no callbacks of this type to run, just don't do anything.
--     case (peek sig cbs)
--      { nothing -> hdl cbs (just (pair cell resumption)) unit (server unit)
--      | (just cb) ->
--        -- First run the callback.
--        let cbResult = cb sig in
--        -- Then remove it from storage.
--        let poppedCbs = pop sig cbs in
--        -- Then check if the cell has had a value put in it as a result.
--        case (readPid cell)
--           -- if we have a result, apply whatever the result of the comp is and then resume
--           { (just result) -> hdl poppedCbs nothing (cbResult; resumption result) (server unit)
--           -- if we do not, just try again
--           | nothing -> hdl poppedCbs (just (pair cell resumption)) unit (server unit)}}

-- hdl cbs res <await cell -> client> <server> =
--     case (readPid cell)
--       { (just x) -> print "straight through\n"; hdl cbs nothing (client x) server!
--       | nothing  -> hdl cbs (just (pair cell client)) unit server! }

hdl _  unit _ = print "over"; unit
hdl _ _ unit = unit

main : {[Console, RefState] Unit}
main! = hdl (callbacks mnil) client! (<RefState>(user!))
