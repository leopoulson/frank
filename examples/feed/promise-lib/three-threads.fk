include std

include callbacks

-- Promise interface
interface Promise =
          promise R : Prom R [Promise, RefState] -> Pid R
        | signal : Sig -> Unit
        | await R : Pid R -> R

interface Tick = tick : Unit

data Prom R [E] = nextCb {Unit -> [E|] R}
                | requestCb {Int -> [E|] R}
                | responseCb {(List Int) -> [E|] R}

-- TODO: Change this to be labels; so that it's op S Int?
data Sig = nextSig Unit | requestSig Int | responseSig (List Int)


-- equality between signals
eqSig : {Sig -> Sig -> Bool}
eqSig (requestSig _) (requestSig _) = true
eqSig (responseSig _) (responseSig _) = true
eqSig (nextSig _) (nextSig _) = true
eqSig _ _ = false

data Pid X = pid (Ref (Maybe X))

readPid : {Pid X -> [RefState] (Maybe X)}
readPid (pid cell) = read cell

-- Given a pid and a callback, rewrites the callback such that it writes the
-- result to the cell and returns unit, whilst still performing effects as before.
-- Adds RefState to the ambient in the promise.
to_write : Pid R -> {S -> [E| RefState]R} -> {S -> [E| RefState] Unit}
to_write (pid cell) cb = {x -> let res = (cb x) in
                               write cell (just res)}

-- Converts a function of Int -> Unit to one of Sig -> unit.
prep_next : {{Unit -> [E|]Unit} -> {Sig -> [E|]Unit}}
prep_next cb = {s -> case (s)
                    { (nextSig x) -> cb x
                    | _ -> unit}}

prep_req : {{Int -> [E|]Unit} -> {Sig -> [E|]Unit}}
prep_req cb = {s -> case (s)
                    { (requestSig x) -> cb x
                    | _ -> unit}}

prep_resp : {{(List Int) -> [E|]Unit} -> {Sig -> [E|]Unit}}
prep_resp cb = {s -> case (s)
                    { (responseSig x) -> cb x
                    | _ -> unit}}

----------------------
-- Thread code
--

client : {[Promise [Console], Console, RefState]Unit}
client! = promise (nextCb
     {_ -> print "oops!\n";
           signal (requestSig 10);
           promise (responseCb {x -> print "response! "; ouint (nth 0 x); print "\n"});
           client!})
    ; unit

-- waits for a request, sends input + 10, reinstalls itself.
requestWaiter : {Int -> [Console, Promise [Console], RefState] Unit}
requestWaiter x =
                  signal (responseSig (range x (x + 10)));
                  promise (requestCb requestWaiter);
                  unit

-- server just installs the repsonse promise which reinstalls itself once it's been used.
server : {[Promise [Console]]Unit}
server! = promise (requestCb requestWaiter); unit

user : {[Console, Promise [Console]] Unit}
user! = inch!;
        signal (nextSig unit); user!

-----------------------
-- Handler / scheduler

apply : {Int -> Int -> {[E|]Unit} -> {[E|]R} -> {[E|]R}}
apply cbId threadId callback thread =
    if (cbId == threadId)
     {{callback!; thread!}}
     {thread}

hdl : {Callbacks [Promise [Console], Console, RefState]  --callbacks, parametrised by effects
    -> <Promise [Console]> Unit -- server
    -> <Promise [Console]> Unit -- client
    -> <Promise [Console]> Unit -- user
    -> [Console, RefState] Unit}

-- Installing promises
-- cbMod is the original callback, modified to make its input and return types generic.
hdl cbs <promise (requestCb cb) -> server> <client> <user> =
    let cell = pid (new nothing) in
    let cbMod = (prep_req (to_write cell cb)) in
    hdl (snocOrInsert (requestSig 0) (pair 0 cbMod) cbs) (server cell) client! user!

hdl cbs <server> <promise (nextCb cb) -> client> <user> =
    let cell = pid (new nothing) in
    let cbMod = (prep_next (to_write cell cb)) in
    hdl (snocOrInsert (nextSig unit) (pair 1 cbMod) cbs) server! (client cell) user!

hdl cbs <server> <promise (responseCb cb) -> client> <user> =
    let cell = pid (new nothing) in
    let cbMod = (prep_resp (to_write cell cb)) in
    hdl (snocOrInsert (responseSig nil) (pair 1 cbMod) cbs) server! (client cell) user!

hdl cbs <signal sig -> server> <client> <user> =
    -- Look to see if there's any promises of this type waiting.
    case (peek sig cbs)
      -- if not, do nothing and return.
      { nothing -> hdl cbs (server unit) client! user!
      -- if there is, run it on the source thread.
      | (just (pair id cb)) -> hdl (pop sig cbs)
                                   ((apply id 0 {cb sig} {server unit})!)
                                   ((apply id 1 {cb sig} client)!)
                                   ((apply id 2 {cb sig} user)!)}

hdl cbs <server> <signal sig -> client> <user> =
    -- Look to see if there's any promises of this type waiting.
    case (peek sig cbs)
      -- if not, do nothing and return.
      { nothing -> hdl cbs server! (client unit) user!
      -- if there is, run it on the source thread.
      | (just (pair id cb)) -> hdl (pop sig cbs)
                                   ((apply id 0 {cb sig} server)!)
                                   ((apply id 1 {cb sig} {client unit})!)
                                   ((apply id 2 {cb sig} user)!)}

-- Processing incoming signals without blocked computation.
hdl cbs <server> <client> <signal sig -> user> =
    -- Look to see if there's any promises of this type waiting.
    case (peek sig cbs)
      -- if not, do nothing and return.
      { nothing -> hdl cbs server! client! (user unit)
      -- if there is, run it on the source thread.
      | (just (pair id cb)) -> hdl (pop sig cbs)
                                   ((apply id 0 {cb sig} server)!)
                                   ((apply id 1 {cb sig} client)!)
                                   ((apply id 2 {cb sig} {user unit})!)}

hdl _ unit _ _ = unit
hdl _ _ unit _ = unit
hdl _ _ _ unit = unit

main : {[Console, RefState] Unit}
main! = hdl (cbnil) (<RefState, Console>(server!)) ((client!)) (<RefState>(user!))
