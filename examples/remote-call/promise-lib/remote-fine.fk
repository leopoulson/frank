include std

include callbacks_op

----------------------------
-- Pids

data Pid X = pid (Ref (PromiseStatus X))



data PromiseStatus X = empty | done X | addRes {X -> Unit}

readPid : {Pid X [E|] -> [RefState] PromiseStatus X [E|]}
readPid (pid cell) = read cell

writePid : {Pid X [E|] -> PromiseStatus X [E|] -> [RefState] Unit}
writePid (pid cell) x = write cell x

----------------------------
-- Promise structures.

interface Promise =
          promise R : Prom R [Promise, RefState] -> Pid R [Promise, RefState]
        | signal : Sig -> Unit
        | await R : Pid R [Promise, RefState] -> R

data Op = call | result | cancel

data Prom R [E] = intCb Op {Int -> [E|] R}
                | pairCb Op {Pair String Int -> [E|] R}

data Sig = intSig Op Int
         | pairSig Op (Pair String Int)

eqOp : {Op -> Op -> Bool}
eqOp call call = true
eqOp result result = true
eqOp cancel cancel = true
eqOp _ _ = false

getOp : {Sig -> Op}
getOp (intSig op _) = op
getOp (pairSig op _) = op

printOp : {Op -> [Console]Unit}
printOp call = print "call"
printOp result = print "result"
printOp cancel = print "cancel"

printSig : {Sig -> [Console]Unit}
printSig (intSig op x) = printOp op; print " "; ouint x
printSig (pairSig op (pair st x)) = printOp op; print " "; print st; print " "; ouint x

----------------------------
-- Callback utilities


prepInt : {Op -> {Int -> [E|]Unit} -> {Sig -> [E|] Unit}}
prepInt op cb = {s -> case (s)
                     { (intSig op x) -> cb x
                     | _ -> unit}}

prepPair : {Op -> {Pair String Int -> [E|]Unit} -> {Sig -> [E|] Unit}}
prepPair op cb = {s -> case (s)
                     { (pairSig op x) -> cb x
                     | _ -> unit}}

apply : {Int -> Sig -> Pair Int {Sig -> [E|] Unit} -> {[E|] R} -> {[E|] R}}
apply threadId arg (pair cbId callback) rest =
    if (cbId == threadId)
       { {callback arg; rest!} }
       { rest }

applyMany : {Int -> Sig -> {[E|] R} -> List (Pair Int {Sig -> [E|] Unit}) -> {[E|] R}}
applyMany threadId arg rest cbs = fold {x y -> apply threadId arg x y} rest cbs

apply2 : {Int -> Sig -> Pair Int {Sig -> [E|] Unit} -> {[E|] Unit} -> {[E|] Unit}}
apply2 threadId arg (pair cbId callback) rest =
    if (cbId == threadId)
       { {callback arg; rest!} }
       { rest }

applyMany2 : {Int -> Sig -> List (Pair Int {Sig -> [E|] Unit}) -> {[E|] Unit}}
applyMany2 threadId arg cbs = fold {x y -> apply2 threadId arg x y} { unit } cbs

----------------------------
-- Threads

resultWaiter : {Int -> [Promise, RefState] Pid String [Promise, RefState]}
resultWaiter callNo =
    promise (pairCb result
      {(pair res callNo') ->
          -- If the call numbers match,
          if (callNo == callNo')
          -- Just return the value
          { res }
          -- Else reinstall the promise and return the value of this.
          { await (resultWaiter callNo) }})

-- Creates a request for the arguments to be evaluated.
-- Returns a thunk that, when executed, awaits the promise.
callWith : {String -> Ref Int -> [Promise , RefState] Pid String [Promise, RefState]}
callWith arg counter =
     let callNo = read counter in
     -- Install the result promise.
     let resultPromise = resultWaiter callNo in
     -- Request that a call is made.
     signal (pairSig call (pair arg callNo));
     -- Increment call counter
     write counter (callNo + 1);
     -- Return thunked process of awaiting the result.
     resultPromise
     -- unit

-- This is the remote web request
remoteRequest : {String -> [Web]String}
remoteRequest arg = getRequest (concat "http://api.mathjs.org/v4/?expr=10*" arg)

remote : {[Promise[Web, Console], RefState, Web, Console] Unit}
remote! =
    promise (pairCb call
      {(pair arg callNo) ->
        -- When a call signal comes in, just perform the request and send the
        -- result back
        let res = remoteRequest arg in
        signal (pairSig result (pair res callNo));
        remote!})
    ; unit

-- This isn't good - we *have* to put [Console] here otherwise it won't execute
caller : {[Promise[Console, Web], Console, RefState, Web] Unit}
caller! = let counter = new 0 in
          let one = callWith "10" counter in
          let oneres = await one in
          print "10 * 10 = "; print oneres; print "\n";

          let two = callWith oneres counter in
          let twores = await two in
          print "10 * 100 = "; print twores; print "\n";
         
          let three = callWith twores counter in
          let threeres = await three in
          print "10 * 1000 = "; print threeres; print "\n";

          unit

----------------------------
-- Handler
to_write : Pid R [E| RefState]-> {S -> [E| RefState]R} -> {S -> [E| RefState] Unit}
to_write (pid cell) cb = {x -> case (read cell)
                             { empty -> write cell (done (cb x))
                             | (addRes resumption) -> resumption (cb x)}}

hdl : {Callbacks [K| Promise [K|], RefState]
    -> <Promise[K|]> Unit -- thread one
    -> [K| RefState] Unit}

----- Awaiting Promises
hdl cbs <await cell -> th1> =
    case (readPid cell)
         { (done x) -> hdl cbs (th1 x)
         | empty -> writePid cell (addRes th1);
                    hdl cbs unit}

----- Installing Promises
hdl cbs <promise (pairCb op cb) -> th1> =
    -- Create new pid cell
    let cell = pid (new empty) in
    -- Convert callback to 'generic' form
    let cbMod = prepPair op (to_write cell cb) in
    -- Add to callbacks and carry on.
    hdl (snocOrInsert op (pair 0 cbMod) cbs) (th1 cell)

----- Executing promises based on signals.
hdl cbs <signal sig -> th1> =
    let op = getOp sig in
    let cbsHere = lookup op cbs in
    case (cbsHere)
      { nothing -> hdl (clear op cbs) (th1 unit)
      | (just cbsHere') -> hdl (clear op cbs)
                               ((applyMany2 0 sig cbsHere')!; th1 unit) }

hdl _ unit = unit

main : {[Console, RefState, Web]Unit}
main! = hdl cbnil (remote!; caller!)
