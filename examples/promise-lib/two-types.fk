include std

-- Here we need to take multiple promises, store them, and handle
-- We store the promises in a list.

interface Whatever = whatever : Unit

-- Empty datatype used as a type-level string
data OpInt = opInt

data OpStr = opStr

-- Recursive type is required.
interface Promise N S R =
            promise : N -> {S -> [Console] R} -> Unit
          | signal : N -> S -> Unit
          -- | await : R

snoc : {List X -> X -> List X}
snoc nil x = [x]
snoc (y :: ys) x = y :: (snoc ys x)

-- This works, but I don't know why!
client : {[
           Promise OpStr String Unit,
           Promise OpInt Int Unit,
           Console]Unit}
client! =
          (promise opInt {x -> print "running "; ouint (x + 10); print " thanks!\n"})
          ;
          <Promise> (promise opStr {st -> print "runnign str"; print st; print " thanks again!\n"})

-- server : {Int -> [Promise OpInt Int Unit, Whatever, Console] Unit}
-- server x = whatever!; sleep 500000; signal opInt x; server (x + 10)

server : {Int ->
            [
             Promise OpStr String Unit,
             Promise OpInt Int Unit,
             Console] Unit}
server x =
            (signal opInt 24)
            ;
            <Promise> (signal opStr "yes")

-- Executes a list of callbacks by just chaining them.
signalAll : {List {Int -> [E|]Unit} -> Int -> [E|]Unit}
signalAll [] _ = unit
signalAll (cb :: cbs) arg = cb arg ; signalAll cbs arg

hdlProm : {List {Int -> [Console]Unit} -- Response Callbacks
         -> <Promise OpStr String Unit, Promise OpInt Int Unit> Unit
         -- -> <Promise OpInt Int Unit, Promise OpStr String Unit> Unit

         -- -> <Promise OpInt Int Unit> Unit
         -- -> <Promise OpInt Int Unit, Whatever> Unit
         -> <Promise OpStr String Unit, Promise OpInt Int Unit> Unit
         -> [Console]Unit}

-- Installing promise
-- And this catches int?
hdlProm cbs <promise.0 _ cb -> client> <server> =
        print "installing int\n";
         hdlProm cbs (client unit) server!

-- So for whatever reason this catches the int
hdlProm cbs <promise.1 _ cb -> client> <server> =
        print "installing str\n";
        hdlProm cbs (client unit) server!

hdlProm cbs <client> <signal.0 opStr n -> server> =
        print "\nint signal\n";
        -- print st;
        hdlProm cbs (client!) (server unit)

hdlProm cbs <client> <signal.1 _ n -> server> =
        print "\nstr signal\n";
        hdlProm cbs client! (server unit)


-- hdlProm cbs <client> <signal.0 _ n -> server> =
--         print "\nint signal\n";
--         n + 10;
--         hdlProm cbs (client!) (server unit)





-- hdlProm cbs <client> <signal.1 _ n -> server> =
--         ouint n;
--         hdlProm cbs (client!) (server unit)

-- hdlProm cbs <client> <signal opInt x -> server> =
--         hdlProm [] ( (signalAll cbs x); client!) (server unit)

-- hdlProm cb <client> <whatever -> server> =
--          hdlProm cb client! (print "whatever\n"; server unit)

hdlProm _ unit _ = print "\nclient exits\n"
hdlProm _ _ unit = print "\nserver exits\n"

-- hdlTop : {<Promise OpStr String Unit>Unit -> Unit}
-- hdlTop <promise opStr cb -> client> = hdlTop (client unit)

-- handleWhatever : {<Console | Whatever> Unit -> [Console]Unit}
-- handleWhatever <whatever -> k> = print "whatever\n"; handleWhatever (k unit)
-- handleWhatever unit = unit

main : {[Console]Unit}
main! = (hdlProm nil client! (server 0))
