---- This is broken; we can't handle the cancel effect locally, it pops up to the top-level.
-- So we try and move it to having individual threads that run.



include std

include threads_lib_2

---------------------
-- Scheduling

interface Yield = yield : Unit

-- ScheduleT schedules threads, but uses the threads structure for this.
scheduleT : {<Yield> Unit -> Int -> Ref (Threads [E|]) -> [E| RefState]Unit}
scheduleT <yield -> k> cur thrs =
    -- Find which thread id is the next one to be ran.
    -- let readthrs = read thrs in
    let next = (nextId cur (keys (read thrs))) in

    -- Look up this new thunk.
    let newThk = (fromMaybe (lookupThk next (read thrs))) in
    -- Thunk current continuation; write this in threads
    let newThrs = (writeThk cur {k unit} (read thrs)) in
    write thrs newThrs;

    -- Restart with new continuation
    scheduleT newThk! next thrs

-- If the thread ends, just force a yield.
scheduleT unit cur thrs = scheduleT yield! cur thrs

-- Finds the next highest ID in threads.
-- If there isn't one higher, i.e. the current is the max, finds the lowest.
nextId : {Int -> List Int -> Int}
nextId cur xs =
   let lgt = leastGT cur 100 xs in
   if (lgt == 100) -- i.e. cur is max
       { lowest 100 xs }
       { lgt }

----------------------------
-- Promise structures.

interface Promise [E] =
          promise R : Prom R [E|] -> Pid R [E | Promise[E|], RefState, Yield]
        | signal : Sig -> Unit
        | await R : Pid R [E | Promise[E|], RefState, Yield]-> R

-- Effects can be performed in the guard, just NO promises.
data Prom R [E] = prom {Sig -> [E| RefState, Yield] (Maybe {[E| Promise[E|], RefState, Yield]R})}

data Sig = call {[InProm] String} Int | result String Int | cancel Int
-- data Sig = result String Int

----------------------------
-- Pids

data Pid X = pid (Ref (PromiseStatus X))

data PromiseStatus X = waiting | done X | resume {X -> Unit}

readPid : {Pid X [E|] -> [RefState] PromiseStatus X [E|]}
readPid (pid cell) = read cell

writePid : {Pid X [E|] -> PromiseStatus X [E|] -> [RefState] Unit}
writePid (pid cell) x = write cell x

----------------------------
-- Threads

interface LocalCancel = localCancel : Unit

hdlCancel : {<LocalCancel> Unit -> [Console] Unit}
hdlCancel <localCancel -> k> = print "*--- Cancelling\n"; unit
hdlCancel x = x

-- Alias for all of the requisite threads.
interface InPromPre = [Web, Console]
interface InProm = [InPromPre, LocalCancel]
interface WTNP = [InPromPre, RefState, Yield, LocalCancel]
interface WebThreads = [Promise[InProm], WTNP]

-- This is the remote web request
remoteRequest : {String -> [Web]String}
remoteRequest arg = getRequest (concat "http://api.mathjs.org/v4/?expr=10*" arg)

-- Doesn't fire if the callnumber doesn't match.
resultWaiter : {Int -> [WebThreads] Pid String [WebThreads]}
resultWaiter callNo = promise (prom { (result res callNo') -> if (callNo == callNo') { just {res} } {nothing}
                                    | _ -> nothing})

-- Caller takes a process and a callID
-- it sends a signal to run the process, then installs a promise to wait the result.
async : {[InProm] String} -> Ref Int -> [WebThreads] Pid String [WebThreads]
async proc callCounter =
    let callNo = read callCounter in
    -- Install the result waiter before we call.
    let waiter = (resultWaiter callNo) in
    -- Then make the request to perform proc
    signal (call proc callNo);
    -- Increment callcounter
    write callCounter (callNo + 1);
    -- and return the waiter.
    waiter

canceller : {Int -> Sig -> [WTNP] Maybe {[Promise[Web, Console, LocalCancel], LocalCancel, Console, RefState, Web, Yield] Unit}}
canceller callId (cancel callId') =
    if (callId == callId')
        { just {print "Eek!"; localCancel!} }
        { nothing }
canceller _ _ = nothing

-- Need to implement cancelling.
runProc : {{[InProm] String} -> Int -> [WebThreads] Unit}
runProc proc callId =

    promise (prom {s -> canceller callId s});
    print "installed cancelller at "; ouint callId; print "\n";
    yield!;
    -- First, run the process
    let res = <Promise, RefState, Yield> proc! in
    -- Then we want to send a result message w/ the same callId
    signal (result res callId)

onRun : {{[InProm] String} -> Int -> [WebThreads] Unit}
onRun proc callId =
    -- (runProc proc callId);
    <LocalCancel> (hdlCancel (runProc proc callId));
    -- Then finally we reinstall the runner.
    runner!;
    -- and return unit.
    unit

runProm : {Sig -> [WTNP] Maybe {[WebThreads] Unit}}
runProm (call proc callId) = just {  (onRun proc callId) }
runProm _ = nothing

-- Runner needs to wait for call messages to come in. When they do, it should
-- run the process and return.
runner : {[WebThreads] Pid Unit [WebThreads]}
runner! = promise (prom runProm)

runnerTop : {[WebThreads] Unit}
runnerTop! = runner!; unit

caller : {[WebThreads] Unit}
caller! =
    print "Caller starting\n";
    let callCounter = new 0 in
    let p1 = async {print "*- Hey!\n"; "bye!\n"} callCounter in
    yield!;
    print "Caller cancelling\n";
    signal (cancel 0);
    yield!;
    let p2 = async {print "*- Hey 2!\n"; "bye!\n"} callCounter in
    print "in the middle!\n";
    print (await p1)


----------------------------
-- Callback utilities

to_writeM2 : Pid R [E|RefState]
          -> {S -> [K|] (Maybe {[E|RefState] R})}
          -> {S -> [K|] (Maybe {[E|RefState] Unit})}
to_writeM2 (pid cell) cb =
    {x -> case (cb x)
         { nothing -> nothing
         | (just susp) ->
             just {case (read cell)
                      { waiting -> write cell (done susp!)
                      | (resume resumption) -> resumption susp! }}}}

print_yield : {String -> [Console, Yield]Unit}
print_yield st = print st; print "\n";
                 sleep 250000;
                 yield!;
                 print_yield st

----------------------------
----- Handling Promises
----------------------------

hdl : {Int -> Ref (Threads [E|])
    -> <Promise[E|]> Unit
    -> [E| RefState, Yield] Unit}

hdl thId thrs <promise (prom cb) -> k> =
    -- Create new pid cell
    let cell = pid (new waiting) in
    -- Process callback to convert to general form
    let cbMod = (to_writeM2 cell cb) in

    -- Handle callback alongside the rest of the computation.
    let cbMaybe = {sig rest -> case (cbMod sig)
                                 { nothing -> nothing
                                 | (just susp) -> just { hdl thId thrs susp!; rest!} }} in
    let queued = (addCb thId cbMaybe (read thrs)) in

    -- Write the resumption to the cell and resume.
    write thrs queued;
    hdl thId thrs (k cell)

-- So in this case, we want to go to each _thread_ and run the installed callbacks.
hdl thId thrs <signal sig -> thr> =
    let newThrs = (runThreads sig (read thrs)) in

    write thrs newThrs;
    hdl thId thrs (thr unit)

hdl thId thrs <await cell -> thr> =
    case (readPid cell)
        { (done x) ->
            hdl thId thrs (thr x)
        | waiting ->
            writePid cell (resume thr);
            hdl thId thrs unit
        }

hdl thId thrs unit = unit

-------------------------------------
-- Running

thr1 : {Ref (Threads [InProm]) -> {[WTNP] Unit}}
thr1 thrs = {hdl 0 thrs runnerTop!}

thr2 : {Ref (Threads [InProm]) -> {[WTNP] Unit}}
thr2 thrs = {hdl 1 thrs caller!}

-- All of these RefState adaptors are necessary, unfortunately.
makeThreads : {[RefState] Ref (Threads [InProm])}
makeThreads! =
    let thrs = new tnil in
    write thrs (tentry 0 (<RefState> (thr1 thrs)) (tq [])
               (tentry 1 (<RefState> (thr2 thrs)) (tq []) tnil));
    thrs


run : {Ref (Threads [E|]) -> [E| RefState]Unit}
run thrs =
    let readthrs = read thrs in
    let runner = (lookupThk 0 readthrs) in
    case runner
        { nothing -> unit
        | (just runner) -> (scheduleT (runner!) 0 thrs) }

hdled : {[Console, Web, LocalCancel, RefState]Unit}
hdled! =
    let thrs = <Console, Web, LocalCancel> makeThreads! in
    run thrs

cancelThru : <LocalCancel> Unit -> [Console] Unit
cancelThru <localCancel -> k> = print "Cancelling thru\n"; unit -- ;   cancelThru (k unit)
cancelThru x = x

main : {[Console, Web, RefState] Unit}
main! = cancelThru hdled!
