include std

include callbacks_op

-- Yielding needed for pre-emption to work.
interface Yield = yield : Unit

----------------------------
-- Promise structures.

interface Promise =
          promise R : Prom R [Promise, RefState] -> Pid R [Promise, RefState]
        | signal : Sig -> Unit
        | await R : Pid R [Promise, RefState]-> R

data Op = go | stop | reset

data Prom R [E] = intCb Op {Int -> [E|] R}
                | unitCb Op {Unit -> [E|] R}

data Sig = intSig Op Int
         | unitSig Op

eqOp : {Op -> Op -> Bool}
eqOp go go = true
eqOp stop stop = true
eqOp reset reset = true
eqOp _ _ = false

eqSig : {Sig -> Sig -> Bool}
eqSig (intSig op _) (intSig op' _) = eqOp op op'
eqSig (unitSig op) (unitSig op') = eqOp op op'
eqSig _ _ = false

getOp : {Sig -> Op}
getOp (intSig op _) = op
getOp (unitSig op) = op

----------------------------
-- Pids

data Pid X = pid (Ref (PromiseStatus X))

data PromiseStatus X = empty | done X | addRes {X -> Unit}

readPid : {Pid X [E|] -> [RefState] PromiseStatus X [E|]}
readPid (pid cell) = read cell

writePid : {Pid X [E|] -> PromiseStatus X [E|] -> [RefState] Unit}
writePid (pid cell) x = write cell x

----------------------------
-- Threads

counter1 : {Ref Bool -> Ref Int -> [Console, Yield, RefState, Promise[Console, Yield]]Unit}
counter1 reqInProg x = ouint (read x); print " ";
             sleep 200000;
             yield!;
             if (not (read reqInProg))
                { write reqInProg true;
                  promise (unitCb reset { _ -> write x 0;
                                             write reqInProg false }); unit
                }
                { unit };
             write x ((read x) + 1);
             counter1 reqInProg x

-- 'counts' through characters
counter2 : {Int -> [Console, Yield, Promise[Console, Yield], RefState]Unit}
counter2 x = ouch (toc x); print " ";
             sleep 200000;
             yield!;
             if (x > 10) { signal (unitSig reset) } { unit };
             counter2 (x + 1)


goGuarded : {Int -> [Promise[Console, Yield], Console, RefState, Yield] Pid Unit [Console, Yield, Promise[Console, Yield], RefState]}
goGuarded arity =
    promise (intCb go { x -> if ((mod x 2) == arity)
                       { unit }
                       -- Slightly hacky; if we need to reinstall a
                       -- blocked promise we have to await it when we
                       -- call it again.
                       -- This could lead to a very large buildup of awaited thunks?
                       { let goPromise = (goGuarded arity) in await (goPromise)}})

waitForStopGuarded : {Int -> [Console, Promise[Console, Yield], RefState, Yield]Unit}
waitForStopGuarded arity =
    promise (intCb stop { x -> if ((mod x 2) == arity)
                          { let goPromise = (goGuarded arity) in
                            await goPromise;
                            waitForStopGuarded arity }
                          { waitForStopGuarded arity }})
    ; unit

waitForGoGuarded : {Int -> [Console, Promise[Console, Yield], RefState, Yield]Unit}
waitForGoGuarded arity =
    goGuarded arity;
    waitForStopGuarded arity

-- Install an interrupt handler for stopping.
thread1 : {[Promise[Console, Yield], Console, RefState, Yield] Unit}
thread1! = waitForStopGuarded 0; counter1 (new false) (new 0)

thread2 : {[Promise[Console, Yield], Console, RefState, Yield] Unit}
thread2! = waitForGoGuarded 1; counter2 0

-- Utility for controller; breaks down a big sleeping chunk and yields inbetween.
sleepAndYield : Int -> [Console, Yield]Unit
sleepAndYield x = if (x < 0)
              { unit }
              { sleep 100000; yield!; sleepAndYield (x - 100000) }

-- Controller just sends signals and breaks.
controller : {Int -> [Promise [Console, Yield], Console, RefState, Yield] Unit}
controller k = print "\n*- Stop "; ouint k; print "\n";
               signal (intSig stop k);
               print "*- Go "; ouint (k + 1); print "\n";
               signal (intSig go (k + 1));
               sleepAndYield 400000;
               controller (k + 1)

----------------------------
-- Callback utilities

to_write : Pid R [E| RefState]-> {S -> [E| RefState]R} -> {S -> [E| RefState] Unit}
to_write (pid cell) cb = {x -> case (read cell)
                             { empty -> write cell (done (cb x))
                             | (addRes resumption) -> resumption (cb x)}}

prepInt : {Op -> {Int -> [E|]Unit} -> {Sig -> [E|] Unit}}
prepInt op cb = {s -> case (s)
                     { (intSig op x) -> cb x
                     | _ -> unit}}

prepUnit : {Op -> {Unit -> [E|]Unit} -> {Sig -> [E|] Unit}}
prepUnit op cb = {s -> case (s)
                     { (unitSig op) -> cb unit
                     | _ -> unit}}

apply : {Int -> Int -> {[E|]Unit} -> {[E|]R} -> {[E|]R}}
apply cbId threadId callback thread =
    if (cbId == threadId)
     {{callback!; thread!}}
     {thread}

apply2 : {Int -> Sig -> Pair Int {Sig -> [E|] Unit} -> {[E|] R} -> {[E|] R}}
apply2 threadId arg (pair cbId callback) rest =
    if (cbId == threadId)
       { {callback arg; rest!} }
       { rest }

applyMany : {Int -> Sig -> {[E|] R} -> List (Pair Int {Sig -> [E|] Unit}) -> {[E|] R}}
applyMany threadId arg rest cbs = fold {x y -> apply2 threadId arg x y} rest cbs

----------------------------
-- Handler

hdl : {Callbacks [Console, Promise [Console, Yield], RefState, Yield]
    -> <Promise[Console, Yield], Yield> Unit -- thread one
    -> <Promise[Console, Yield], Yield> Unit -- thread two
    -> <Promise[Console, Yield], Yield> Unit -- controller
    -> [Console, RefState] Unit}

----- Awaiting Promises
hdl cbs <await cell -> th1> <th2> <server> =
    case (readPid cell)
         { (done x) -> hdl cbs (th1 x) th2! server!
         | empty -> writePid cell (addRes th1);
                    hdl cbs unit th2! server!}

hdl cbs <th1> <await cell -> th2>  <server> =
    case (readPid cell)
         { (done x) -> hdl cbs th1! (th2 x) server!
         | empty -> writePid cell (addRes th2);
                    hdl cbs th1! unit server!}

----- Installing Promises
hdl cbs <promise (intCb op cb) -> th1> <th2> <control> =
    -- Create new pid cell
    let cell = pid (new empty) in
    -- Convert callback to 'generic' form
    let cbMod = prepInt op (to_write cell cb) in
    -- Add to callbacks and carry on.
    hdl (snocOrInsert op (pair 0 cbMod) cbs) (th1 cell) th2! control!

hdl cbs <promise (unitCb op cb) -> th1> <th2> <control> =
    let cell = pid (new empty) in
    let cbMod = prepUnit op (to_write cell cb) in
    hdl (snocOrInsert op (pair 0 cbMod) cbs) (th1 cell) th2! control!

hdl cbs <th1> <promise (intCb op cb) -> th2> <control> =
    let cell = pid (new empty) in
    let cbMod = prepInt op (to_write cell cb) in
    hdl (snocOrInsert op (pair 1 cbMod) cbs) th1! (th2 cell) control!

----- Executing promises based on signals.
hdl cbs <th1> <th2> <signal sig -> control> =
    let op = getOp sig in
    let cbsHere = lookupHard op cbs in
    hdl (clear op cbs)
        ((applyMany 0 sig th1 cbsHere)!)
        ((applyMany 1 sig th2 cbsHere)!)
        (control unit)

hdl cbs <th1> <signal sig -> th2> <control> =
    let op = getOp sig in
    let cbsHere = lookupHard op cbs in
    hdl (clear op cbs)
        ((applyMany 0 sig th1 cbsHere)!)
        (th2 unit)
        ((applyMany 2 sig control cbsHere)!)

hdl cbs <yield -> th1> <th2> <yield -> control> =
    hdl cbs (th1 unit) th2! (control unit)

hdl cbs <th1> <yield -> th2> <yield -> control> =
    hdl cbs th1! (th2 unit) (control unit)

hdl cbs <yield -> th1> <th2> <control> =
    hdl cbs (th1 unit) th2! control!

hdl cbs <th1> <yield -> th2> <control> =
    hdl cbs th1! (th2 unit) control!

hdl cbs <th1> <th2> <yield -> control> =
    hdl cbs th1! th2! (control unit)

hdl _ unit _ _ = print "thread1 exits"
hdl _ _ unit _ = print "thread2 exits"
hdl _ _ _ unit = print "controller exits"

main : {[Console, RefState]Unit}
main! = hdl cbnil thread1! thread2! (controller 0)
