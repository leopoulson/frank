----- Callbacks stuff

-- This makes use of the fact that Frank just appends includees to the end of
-- the includer, so it leaves `eqSig` to be defined in the includer file.

data Callbacks [E] = cbentry Sig (List (Pair Int {Sig -> [E|]Unit})) (Callbacks [E|])
                   | cbnil


-- More specific functions to our needs.
snocOrInsert : {Sig -> Pair Int {Sig -> [E|] Unit} -> Callbacks [E|] -> Callbacks [E|]}
snocOrInsert sig x cbnil = (cbentry sig [x] cbnil)
snocOrInsert sig x (cbentry sig' xs rest) =
    if (eqSig sig sig')
      { cbentry sig' (snoc xs x) rest }
      { cbentry sig' xs (snocOrInsert sig x rest) }


peek : {Sig -> Callbacks [E|] -> Maybe (Pair Int {Sig -> [E|]Unit})}
peek _   cbnil = nothing
peek sig (cbentry sig' xs rest) =
    if (eqSig sig sig')
       { case (xs)
         { nil -> nothing
         | (cb :: cbs) -> just cb }}
       { peek sig rest }

tail : {List X -> List X}
tail nil = nil
tail (x::xs) = xs

pop : {Sig -> Callbacks [E|] -> Callbacks [E|]}
pop _ cbnil = cbnil
pop sig (cbentry sig' xs rest) =
    if (eqSig sig sig')
       { cbentry sig' (tail xs) rest }
       { cbentry sig' xs (pop sig rest) }

clear : {Sig -> Callbacks [E|] -> Callbacks [E|]}
clear sig cbnil = cbnil
clear sig (cbentry sig' xs rest) =
      cbentry sig' (if (eqSig sig sig') {[]} {xs}) (clear sig rest)

-- Generic map-based stuff
lookup : {Sig -> Callbacks [E|] -> Maybe (List (Pair Int {Sig -> [E|] Unit}))}
lookup _ cbnil = nothing
lookup sig (cbentry sig' v rest) = if (eqSig sig sig') {just v} {lookup sig rest}

lookupHard : {Sig -> Callbacks [E|] -> List (Pair Int {Sig -> [E|] Unit})}
-- lookupHard _ _ (cbnil) = nothing
lookupHard sig (cbentry sig' v rest) = if (eqSig sig sig') {v} {lookupHard sig rest}

delete : {Sig -> Callbacks [E|] -> Callbacks [E|]}
delete _ cbnil = cbnil
delete sig (cbentry sig' v rest) = if (eqSig sig sig') {delete sig rest} {cbentry sig' v (delete sig rest)}

insert : Sig -> List (Pair Int {Sig -> [E|]Unit}) -> Callbacks [E|] -> Callbacks [E|]
insert key value m = cbentry key value m

