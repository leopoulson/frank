include std

include map

include helpers_cb

-- Yielding needed for pre-emption to work.
interface Yield = yield : Unit

----------------------------
-- Promise structures.

interface Promise =
          promise R : Prom R [Promise, RefState] -> Pid R
        | signal : Sig -> Unit
        | await R : Pid R -> R

data Prom R [E] = goCb {Unit -> [E|] R}
                | stopCb {Unit -> [E|] R}

data Callbacks [E] = callbacks (Map Sig (List (Pair Int {Sig -> [E|]Unit})))


-- TODO: Change this to be labels; so that it's op S Int?
data Sig = goSig Unit | stopSig Unit

eqSig : {Sig -> Sig -> Bool}
eqSig (goSig _) (goSig _) = true
eqSig (stopSig _) (stopSig _) = true
eqSig _ _ = false

-- Process ID
data Pid X = pid (Ref (Maybe X))

readPid : {Pid X -> [RefState] (Maybe X)}
readPid (pid cell) = read cell

----------------------------
-- Threads

counter : {Int -> [Console, Yield]Unit}
counter x = ouint x; print " ";
            sleep 200000;
            yield!;
            counter (x + 1)

-- Install an interrupt handler for stopping.
waitForStop : {[Console, Promise[Console], RefState]Unit}
waitForStop! =
    promise (stopCb { _ ->
                       print "stopping\n";
                       -- When we receive stop, we stop; so we install go and
                       -- block on it.
                       let goPromise = promise (goCb {_ -> unit}) in
                       await goPromise;
                       -- Once go has been sent, we allow the thread to continue
                       -- computing and reinstall the stop waiter.
                       waitForStop!})
    ; unit

thread1 : {[Promise[Console], Console, RefState, Yield] Unit}
thread1! = print "starting"; <Yield>(waitForStop!); counter 0


controller : {[Promise [Console], Console, RefState, Yield] Unit}
controller! = print "\n*- Stop\n"; -- signal (stopSig unit)
              sleep 500000;
              yield!;
              print "\n*- Go\n"; -- signal (goSig unit)
              sleep 500000;
              yield!;
              controller!

----------------------------
-- Callback utilities

to_write : Pid R -> {S -> [E| RefState]R} -> {S -> [E| RefState] Unit}
to_write (pid cell) cb = {x -> let res = (cb x) in
                               write cell (just res)}

prepStop : {{Unit -> [E|] Unit} -> {Sig -> [E|] Unit}}
prepStop cb = {s -> case (s)
                   { (stopSig x) -> cb x
                   | _ -> unit}}


apply : {Int -> Int -> {[E|]Unit} -> {[E|]R} -> {[E|]R}}
apply cbId threadId callback thread =
    if (cbId == threadId)
     {{callback!; thread!}}
     {thread}

----------------------------
-- Handler

hdl : {Callbacks [Console, Promise [Console], RefState]
    -> Maybe (Pair (Pid R) {R -> [Console, Promise [Console], RefState, Yield] Unit})
    -> <Promise[Console], Yield> Unit -- thread
    -> <Promise[Console], Yield> Unit -- controller
    -> [Console, RefState] Unit}

----- Installing Promises
hdl cbs res <promise (stopCb cb) -> th1> <control> =
    print "stop installed\n";
    let cell = pid (new nothing) in
    let cbMod = (prepStop (to_write cell cb)) in
    hdl  (snocOrInsert (stopSig unit) (pair 0 cbMod) cbs) res (th1 cell) control!


----- Executing promises based on signals.
hdl cbs nothing <th1> <signal sig -> control> =
    -- Look to see if there's any matching promises waiting.
    case (peek sig cbs)
    -- If there isn't, do nothing and carry on.
      { nothing -> hdl cbs nothing th1! (control unit)
      | (just (pair id cb)) -> hdl (pop sig cbs) nothing
                                   (<Yield>(cb sig); th1!)
                                   (control unit)}
                                   -- (<Yield>(apply id 0 {cb sig} th1)!)
                                   -- ((apply id 0 {(cb sig)} (<Yield> (th1!)))!)
                                   -- -- unit
                                   -- unit}
                                   -- ((apply id 1 {cb sig} {control unit})!)}

-- hdl cbs (just (pair cell resumption)) unit <signal sig -> control> =
--     case (peek sig cbs)
--       { nothing -> hdl cbs (just (pair cell resumption)) unit (control unit)
--       -- Keep simple for now; we know that the callback will be the one that the
--       -- thread is awaiting.
--       | (just (pair id cb)) -> hdl (pop sig cbs) nothing
--                                -- (cb unit; resumption (readPid cell))
--                                (<Yield>(cb sig); resumption (readPid cell))
--                                (control unit)}




hdl cbs res <yield -> th1> <control> =
    hdl cbs res (th1 unit) control!

hdl cbs res <th1> <yield -> control>  =
    hdl cbs res th1! (control unit)

hdl _ _ unit _ = print "thread1 exits"
hdl _ _ _ unit = print "controller exits"

main : {[Console, RefState]Unit}
-- main! = hdl (callbacks mnil) nothing (thread1!) (<RefState>(controller!))
main! = hdl (callbacks mnil) nothing (thread1!) ((controller!))
-- main! = hdl (callbacks mnil) nothing (unit) ((unit))
