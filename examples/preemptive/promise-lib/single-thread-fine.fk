include std

include callbacks

-- Yielding needed for pre-emption to work.
interface Yield = yield : Unit

----------------------------
-- Promise structures.

interface Promise =
          promise R : Prom R [Promise, RefState] -> Pid R [Promise, RefState]
        | signal : Sig -> Unit
        | await R : Pid R [Promise, RefState]-> R

data Prom R [E] = goCb {Unit -> [E|] R}
                | stopCb {Unit -> [E|] R}

-- data Callbacks [E] = callbacks (Map Sig (List (Pair Int {Sig -> [E|]Unit})))

data Sig = goSig Unit | stopSig Unit

eqSig : {Sig -> Sig -> Bool}
eqSig (goSig _) (goSig _) = true
eqSig (stopSig _) (stopSig _) = true
eqSig _ _ = false


----------------------------
-- Pids

data Pid X = pid (Ref (PromiseStatus X))

data PromiseStatus X = empty | done X | addRes {X -> Unit}

readPid : {Pid X [E|] -> [RefState] PromiseStatus X [E|]}
readPid (pid cell) = read cell

writePid : {Pid X [E|] -> PromiseStatus X [E|] -> [RefState] Unit}
writePid (pid cell) x = write cell x

----------------------------
-- Threads

counter : {Int -> [Console, Yield]Unit}
counter x = ouint x; print " ";
            sleep 200000;
            yield!;
            counter (x + 1)

-- Install an interrupt handler for stopping.
waitForStop : {[Console, Promise[Console], RefState]Unit}
waitForStop! =
    promise (stopCb { _ ->
                       -- When we receive stop, we stop; so we install go and
                       -- block on it.
                       let goPromise = promise (goCb {_ -> unit}) in
                       await goPromise;
                       -- Once go has been sent, we allow the thread to continue
                       -- computing and reinstall the stop waiter.
                       waitForStop!})
    ; unit

sleepAndYield : Int -> [Console, Yield]Unit
sleepAndYield x = if (x < 0)
              { unit }
              { sleep 100000; yield!; sleepAndYield (x - 100000) }

thread1 : {[Promise[Console], Console, RefState, Yield] Unit}
thread1! = print "starting"; <Yield>(waitForStop!); (counter 0)

controller : {[Promise [Console], Console, RefState, Yield] Unit}
controller! = print "\n*- Stop\n"; signal (stopSig unit);
              sleepAndYield 400000;
              print "\n*- Go\n"; signal (goSig unit);
              sleepAndYield 400000;
              controller!

----------------------------
-- Callback utilities

to_write : Pid R [E| RefState]-> {S -> [E| RefState]R} -> {S -> [E| RefState] Unit}
to_write (pid cell) cb = {x -> case (read cell)
                             { empty -> write cell (done (cb x))
                             | (addRes resumption) -> resumption (cb x)}}

prepStop : {{Unit -> [E|] Unit} -> {Sig -> [E|] Unit}}
prepStop cb = {s -> case (s)
                   { (stopSig x) -> cb x
                   | _ -> unit}}

prepGo : {{Unit -> [E|] Unit} -> {Sig -> [E|] Unit}}
prepGo cb = {s -> case (s)
                   { (goSig x) -> cb x
                   | _ -> unit}}

apply : {Int -> Int -> {[E|]Unit} -> {[E|]R} -> {[E|]R}}
apply cbId threadId callback thread =
    if (cbId == threadId)
     {{callback!; thread!}}
     {thread}

----------------------------
-- Handler

hdlSgl : {Callbacks [K| Promise [K|], RefState]
    -> <Promise[K|]> Unit -- thread
    -> [K| RefState] Unit}

----- Installing Promises
hdlSgl cbs <promise (stopCb cb) -> th1> =
    -- Create new pid cell
    let cell = pid (new empty) in
    -- Process callback to convert to correct form
    let cbMod = (prepStop (to_write cell cb)) in
    -- Add to list and resume.
    hdlSgl (snocOrInsert (stopSig unit) (pair 0 cbMod) cbs) (th1 cell)
    -- hdlSgl (cbs) (th1 cell) control!

hdlSgl cbs <promise (goCb cb) -> th1> =
    let cell = pid (new empty) in
    let cbMod = prepGo (to_write cell cb) in
    hdlSgl (snocOrInsert (goSig unit) (pair 0 cbMod) cbs) (th1 cell)

----- Executing promises based on signals.
hdlSgl cbs <signal sig -> th1> =
    -- Look to see if there's any matching promises waiting.
    case (peek sig cbs)
    -- If there isn't, do nothing and carry on.
      { nothing -> hdlSgl cbs (th1 unit)
      | (just (pair id cb)) -> hdlSgl (pop sig cbs)
                                   ((cb sig); (th1 unit))}

hdlSgl cbs <await cell -> client> =
    case (readPid cell)
         { (done x) -> hdlSgl cbs (client x)
         | empty -> writePid cell (addRes client);
                    hdlSgl cbs unit}

hdl : {Callbacks [K| Promise [K|], RefState]
    -> <Promise[K|]> Unit -- thread
    -> <Promise[K|]> Unit -- controller
    -> [K| RefState] Unit}

----- Installing Promises
hdl cbs <promise (stopCb cb) -> th1> <control> =
    -- Create new pid cell
    let cell = pid (new empty) in
    -- Process callback to convert to correct form
    let cbMod = (prepStop (to_write cell cb)) in
    -- Add to list and resume.
    hdl (snocOrInsert (stopSig unit) (pair 0 cbMod) cbs) (th1 cell) control!
    -- hdl (cbs) (th1 cell) control!

hdl cbs <promise (goCb cb) -> th1> <control> =
    let cell = pid (new empty) in
    let cbMod = prepGo (to_write cell cb) in
    hdl (snocOrInsert (goSig unit) (pair 0 cbMod) cbs) (th1 cell) control!

----- Executing promises based on signals.
hdl cbs <th1> <signal sig -> control> =
    -- Look to see if there's any matching promises waiting.
    case (peek sig cbs)
    -- If there isn't, do nothing and carry on.
      { nothing -> hdl cbs th1! (control unit)
      | (just (pair id cb)) -> hdl (pop sig cbs)
                                   (<Yield>(cb sig); th1!)
                                   (control unit)}

hdl cbs <await cell -> client> <server> =
    case (readPid cell)
         { (done x) -> hdl cbs ((client x)) server!
         | empty -> writePid cell (addRes client);
                    hdl cbs unit server!}
                   
-- hdl cbs <yield -> thr> <yield -> control> =
--     hdl cbs (thr unit) (control unit)

-- hdl cbs <yield -> th1> <control> =
--     hdl cbs (th1 unit) control!

-- hdl cbs <th1> <yield -> control> =
--     hdl cbs th1! (control unit)

hdl _ unit _ = unit
hdl _ _ unit = unit

main : {[Console, RefState]Unit}
main! = hdlSgl cbnil (thread1!; controller!)
