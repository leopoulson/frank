interface Es = [Console, RefState, Yield]

data TQueue X = tq (List X)

enqueue : {X -> TQueue X -> TQueue X}
enqueue x (tq xs) = tq (snoc xs x)

dequeue : {TQueue X -> Maybe (Pair X (TQueue X))}
dequeue (tq []) = nothing
dequeue (tq (x :: xs)) = just (pair x (tq xs))

data Threads = tentry Int {{[Es] Unit}} (TQueue {Sig -> {[Es] Unit} -> {[Es] Unit}}) Threads
             | tnil

keys : {Threads -> List Int}
keys tnil = []
keys (tentry k _ _ rest) = k :: keys rest

-- Adds a callback cb for thread id k
addCb : {Int -> {Sig -> {[Es] Unit} -> {[Es] Unit}} -> Threads -> Threads}
addCb k cb tnil = tnil
addCb k cb (tentry k' thk q rest) =
   if (k == k')
     { tentry k' thk (enqueue cb q) rest }
     { tentry k' thk q (addCb k cb rest) }

writeThk : {Int -> {{[Es] Unit}} -> Threads -> Threads}
writeThk _ _ tnil = tnil
writeThk k newThk (tentry k' thk q rest) =
    if (k == k')
      { tentry k' newThk q rest }
      { tentry k' thk q (writeThk k newThk rest) }



lookupThk : {Int -> Threads -> Maybe {{[Es] Unit}}}
lookupThk k tnil = nothing
lookupThk k (tentry k' thk _ rest) =
    if (k == k')
      { just thk }
      { lookupThk k rest }


runThreads : {Sig -> Threads -> Threads}
runThreads _ (tnil) = tnil
runThreads sig (tentry k susp cbs rest) =
    -- Run the given thread w/ the incoming signal.
    let pUp = <Console, RefState, Yield>(runThread sig (pair susp cbs)) in
    -- Do the same on the rest of them.
    tentry k (fst pUp) (snd pUp) (runThreads sig rest)

runThread : {Sig -> Pair {{[E|] Unit}}
                         (TQueue {Sig -> {[E|]Unit} -> {[E|]Unit}})
          -> (Pair {{[E|] Unit}}
                  (TQueue {Sig -> {[E|]Unit} -> {[E|]Unit}}))}
runThread sig (pair susp cbs) =
    case (dequeue cbs)
        -- If we have nothing left to run, just stop and return.
        { nothing -> pair susp cbs
        | (just (pair cb cbs)) -> let susp2 = cb sig susp! in
                                  runThread sig (pair {susp2} cbs)}
