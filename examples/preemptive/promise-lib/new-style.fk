include std

-- include callbacks

include map

---------------------
-- Scheduling

interface Yield = yield : Unit

-- ScheduleT schedules threads, but uses the threads structure for this.
scheduleT : {<Yield> Unit -> Int -> Ref Threads -> [Console, RefState]Unit}
scheduleT <yield -> k> cur thrs =
    -- Find which thread id is the next one to be ran.
    let readthrs = read thrs in
    let next = <Console, RefState> (nextId cur (keys (unthreads readthrs))) in

    -- Look up this new thunk.
    let newThk = fromMaybe (lookupThk next thrs) in
    -- Thunk the continuation
    -- Write this in the corresponding place in the threads structure
    <Console>(writeThk {{k unit}} cur thrs);

    -- Run the new thunk.
    let newMod = <Console, RefState> newThk! in
    scheduleT newMod! next thrs

-- If the thread ends, just force a yield.
scheduleT unit cur thrs = sleep 500000; scheduleT yield! cur thrs

-- Finds the next highest ID in threads.
-- If there isn't one higher, i.e. the current is the max, finds the lowest.
nextId : {Int -> List Int -> Int}
nextId cur xs =
   let lgt = leastGT cur 100 xs in
   if (lgt == 100) -- i.e. cur is max
       { lowest 100 xs }
       { lgt }


----------------------------
-- Promise structures.

interface Promise [E] =
          promise R : Prom R [E| Promise[E|], RefState, Yield] -> Pid R [E|Promise[E|], RefState, Yield]
        | signal : Sig -> Unit
        | await R : Pid R [E|Promise[E|], RefState, Yield]-> R

data Prom R [E] = printCb {String -> [E|] R}

----- REMEMBER TO ADD EQSIG
data Sig = printSig String

eqSig : {Sig -> Sig -> Bool}
eqSig (printSig _) (printSig _) = true
eqSig _ _ = false


----------------------------
-- Pids

data Pid X  = pid (Ref (PromiseStatus X ))

data PromiseStatus X  = empty | done X | addRes {X ->  Unit}

readPid : {Pid X [E|] -> [RefState] PromiseStatus X [E|]}
readPid (pid cell) = read cell

writePid : {Pid X [E|] -> PromiseStatus X [E|] -> [RefState] Unit}
writePid (pid cell) x = write cell x

----------------------------
-- Threads

printer : {[Promise[Console], Yield, Console] Unit}
printer! = print "Printer starting\n";
           promise (printCb { x -> print "\n*- "; print x ; print "\n"});
           yield!;
           promise (printCb { x -> print "\n*- 2 "; print x ; print "\n"});
           yield!;
           promise (printCb { x -> print "\n*- 3 "; print x ; print "\n"});
           yield!;
           unit

printer2: {[Promise[Console], Yield, Console] Unit}
printer2! = print "Printer2 starting\n";
           promise (printCb { x -> print "*-"; print " Two! "; print x ; print "\n"});
           unit

sender : {[Promise[Console], Yield, Console]Unit}
sender! = print "Sender starting\n";
          signal (printSig "One");
          yield!;
          signal (printSig "Two");
          yield!;
          signal (printSig "Three");
          yield!;
          unit

catter : {[Console, Yield] Unit}
catter! = print "Beppy\n";
          sleep 200000;
          yield!;
          catter!
         

-- Utility for controller; breaks down a big sleeping chunk and yields inbetween.
sleepAndYield : Int -> [Console, Yield]Unit
sleepAndYield x = if (x < 0)
              { unit }
              { sleep 100000; yield!; sleepAndYield (x - 100000) }


----------------------------
-- Callback utilities

to_write : Pid R [E| RefState]-> {S -> [E| RefState]R} -> {S -> [E| RefState] Unit}
to_write (pid cell) cb = {x -> case (read cell)
                             { empty -> write cell (done (cb x))
                             | (addRes resumption) -> resumption (cb x)}}


prepPrint : {{String -> [E|]Unit} -> {Sig -> [E|] Unit}}
prepPrint cb = {s -> case (s)
                   { (printSig x) -> cb x
                   | _ -> unit}}

print_yield : {String -> [Console, Yield]Unit}
print_yield st = print st; print "\n";
                 sleep 250000;
                 yield!;
                 print_yield st
----------------------------
-- Handler

modifyCell : {Ref X -> {X -> [RefState] X} -> [RefState] Unit}
modifyCell cell fn = write cell (fn (read cell))

onSnd : {{Y -> Z} -> Pair X Y -> Pair X Z}
onSnd f (pair x y) = pair x (f y)

data TQueue X = tq (List X)

enqueueT : {X -> TQueue X -> TQueue X}
enqueueT x (tq xs) = tq (snoc xs x)

dequeueT : {TQueue X -> Maybe (Pair X (TQueue X))}
dequeueT (tq []) = nothing
dequeueT (tq (x :: xs)) = just (pair x (tq xs))

data Threads = threads (Map (Pair {{[Console, RefState, Yield]Unit}}
                            (TQueue {Sig -> {[Console, RefState, Yield] Unit} -> {[Console, RefState, Yield] Unit}})))

unthreads : {Threads -> (Map (Pair {{[Console, RefState, Yield]Unit}}
                            (TQueue {Sig -> {[Console, RefState, Yield] Unit} -> {[Console, RefState, Yield] Unit}})))}
unthreads (threads k) = k

mapAppend : {Int -> {Sig -> {[E|]Unit} -> {[E|]Unit}}
          -> Map (Pair {{[E|]Unit}} (TQueue {Sig -> {[E|] Unit} -> {[E|] Unit}}))
          -> Map (Pair {{[E|]Unit}} (TQueue {Sig -> {[E|] Unit} -> {[E|] Unit}}))}
mapAppend k f map = modifyMap k {p -> onSnd {q -> enqueueT f q} p} map

enqueueMap : {Int -> V -> Map (Pair F (TQueue V)) -> Map (Pair F (TQueue V))}
enqueueMap _ _ mnil = mnil
enqueueMap k f (mentry k' (pair susp q) rest) =
    if (k == k')
        { mentry k' (pair susp (enqueueT f q)) rest }
        { mentry k' (pair susp q) (enqueueMap k f rest) }

-- On each pair of thread and callback queue, execute the threads.
runThreads : {Sig -> Threads -> Threads}
runThreads _ (threads mnil) = threads mnil
runThreads sig (threads (mentry k p rest)) =
    -- Run the given thread w/ the incoming signal.
    let pUp = <Console, RefState, Yield>(runThread sig p) in
    -- Do the same on the rest of them.
    threads (mentry k pUp (unthreads (runThreads sig (threads rest))))

runThread : {Sig -> Pair {{[E|] Unit}}
                         (TQueue {Sig -> {[E|]Unit} -> {[E|]Unit}})
          -> (Pair {{[E|] Unit}}
                  (TQueue {Sig -> {[E|]Unit} -> {[E|]Unit}}))}
runThread sig (pair susp cbs) =
    case (dequeueT cbs)
        -- If we have nothing left to run, just stop and return.
        { nothing -> pair susp cbs
        | (just (pair cb cbs)) -> let susp2 = cb sig susp! in
                                  runThread sig (pair {susp2} cbs)}

-- writeThk : {{{[Console, RefState, Yield]Unit}} -> Int -> Ref Threads -> [RefState]Unit}
writeThk : {{{[Console, RefState, Yield]Unit}} -> Int -> Ref Threads -> [RefState]Unit}
writeThk thk thId thrs =
    let readthrs = read thrs in
    let umap = <RefState>(unthreads readthrs) in
    let modMap = modifyMap thId {p -> pair thk (snd p)} umap in
    write thrs (threads modMap)

lookupThk : {Int -> Ref Threads -> [RefState, Console] Maybe {{[Console, RefState, Yield] Unit}}}
lookupThk thId thrs =
    let readthrs = read thrs in
    let umap = <RefState, Console> (unthreads readthrs) in
    let p = lookup thId umap in
    case p
         { nothing -> print "Can't find thunk "; ouint thId; nothing
         | (just (pair th _)) -> just th}


----------------------------
----- Handling Promises
----------------------------

hdl : {Int -> Ref Threads
    -> <Promise[Console]> Unit
    -> [Yield, Console, RefState] Unit}

-- WTF
hdl thId thrs <promise (printCb cb) -> k> =
    -- print "installing promise\n";
    -- Create new pid cell
    let cell = pid (new empty) in
    -- Process callback to convert to general form
    let cbMod = prepPrint (to_write cell cb) in

    -- Handle callback alongside the rest of the computation.
    let cb3 = {sig rest -> { hdl thId thrs (cbMod sig; <Promise> rest!)}} in
    let readthrs = read thrs in
    let umap = <Console, RefState, Yield>(unthreads readthrs) in
    let queued = enqueueMap thId cb3 umap in
    write thrs (threads queued);

    -- Write the resumption to the cell and resume.
    let res = {{(hdl thId thrs (k cell))}} in
    <Console, Yield>(writeThk res thId thrs);
    (<Console, RefState, Yield> res!)!

-- So in this case, we want to go to each _thread_ and run the installed callbacks.
hdl thId thrs <signal sig -> thr> =
    -- print "Executing signal\n";
    -- update the threads w/ new signal
    let readthrs = read thrs in
    let newThrs = <Console, Yield, RefState>(runThreads sig (readthrs)) in
    write thrs newThrs;

    let res = {{hdl thId thrs (thr unit)}} in
    <Console, Yield>(writeThk res thId thrs);
    (<Console, RefState, Yield> res!)!

hdl thId thrs <await cell -> thr> =
    case (readPid cell)
         { (done x) ->
                 let res = {{hdl thId thrs (thr x)}} in
                 <Console, Yield>(writeThk res thId thrs);
                 (<Console, RefState, Yield> res!)!
--          -- thr2 has Fork in ambient, but addRes won't allow that.
         | empty -> writePid cell (addRes thr);
                    let res = {{hdl thId thrs unit}} in
                    <Console, Yield>(writeThk res thId thrs);
                    (<Console, RefState, Yield> res!)!}

hdl thId thrs unit = unit

-------------------------------------
-- Running

-- unsafe, obviously
fromMaybe : {Maybe X -> X}
fromMaybe (just x) = x

hdled : {[Console, RefState]Unit}
hdled! =
    let thrs = new (threads mnil) in
    write thrs (threads (mentry 0 (pair {{ hdl 0 thrs (<RefState> printer!) }} (tq []))
                        (mentry 1 (pair {{ hdl 1 thrs (<RefState> sender!) }} (tq [])) mnil)));

    let runner = (lookupThk 0 thrs) in
    case runner
        { nothing -> unit
        | (just runner) -> scheduleT ((<Console, RefState, Yield> runner!)!) 0 (thrs)}


-- -- Three threads, printing out cat names.
-- cats : {[Console]Unit}
-- cats! = scheduleQ ( print_yield "Beppy" )
--                   ( enqueue 1 { print_yield "Botsman" } (
--                            enqueue 2 { print_yield "Timmy"} qnil!
                                   -- ) )

main : {[Console, RefState] Unit}
main! = hdled!
-- main! = ouint (nextId 0 [0, 1])-- hdled!
