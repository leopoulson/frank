---------------- Helpers
-- snocOrInsert : {Sig -> X -> Map Sig (List X) -> Map Sig (List X)}
-- snocOrInsert sig x mnil = mentry sig [x] mnil
-- snocOrInsert sig x (mentry sig' xs rest) =
--     if (eqSig sig sig')
--       { mentry sig' (snoc xs x) rest }
--       { mentry sig' xs (snocOrInsert sig x rest) }


-- peek : {Sig -> Map Sig (List X) -> Maybe X}
-- peek _ mnil = nothing
-- peek sig (mentry sig' xs rest) =
--     if (eqSig sig sig')
--        { case (xs)
--          { nil -> nothing
--          | (cb :: cbs) -> just cb }}
--        { peek sig rest }

-- tail : {List X -> List X}
-- tail nil = nil
-- tail (x::xs) = xs

-- pop : {Sig -> Map Sig (List X) -> Map Sig (List X)}
-- pop _ mnil = mnil
-- pop sig (mentry sig' xs rest) =
--     if (eqSig sig sig')
--        { mentry sig' (tail xs) rest}
--        { mentry sig' xs (pop sig rest) }
---------------- end helpers

unCB : Callbacks [E|] -> (Map Sig (List (Pair Int {Sig -> [E|]Unit})))
unCB (callbacks m) = m

snocOrInsert : {Sig -> Pair Int {Sig -> [E|] Unit} -> Callbacks [E|] -> Callbacks [E|]}
snocOrInsert sig x (callbacks mnil) = callbacks (mentry sig [x] mnil)
snocOrInsert sig x (callbacks (mentry sig' xs rest)) =
    if (eqSig sig sig')
      { callbacks (mentry sig' (snoc xs x) rest) }
      { callbacks (mentry sig' xs (unCB (snocOrInsert sig x (callbacks rest)))) }


peek : {Sig -> Callbacks [E|] -> Maybe (Pair Int {Sig -> [E|]Unit})}
peek _ (callbacks mnil) = nothing
peek sig (callbacks (mentry sig' xs rest)) =
    if (eqSig sig sig')
       { case (xs)
         { nil -> nothing
         | (cb :: cbs) -> just cb }}
       { peek sig (callbacks rest) }

tail : {List X -> List X}
tail nil = nil
tail (x::xs) = xs

pop : {Sig -> Callbacks [E|] -> Callbacks [E|]}
pop _ (callbacks mnil) = (callbacks mnil)
pop sig (callbacks (mentry sig' xs rest)) =
    if (eqSig sig sig')
       { callbacks (mentry sig' (tail xs) rest) }
       { callbacks (mentry sig' xs (unCB (pop sig (callbacks rest)))) }
