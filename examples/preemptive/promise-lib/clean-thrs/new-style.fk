include std

include threads_lib

---------------------
-- Scheduling

interface Yield = yield : Unit

-- -- ScheduleT schedules threads, but uses the threads structure for this.
scheduleT : {<Yield> Unit -> Int -> Ref (Threads [Console, RefState, Yield]) -> [Console, RefState]Unit}
scheduleT <yield -> k> cur thrs =
    -- Find which thread id is the next one to be ran.
    let readthrs = read thrs in
    let next = <Console, RefState> (nextId cur (keys readthrs)) in

    -- Look up this new thunk.
    let newThk = <Console, RefState>(fromMaybe (lookupThk next (readthrs))) in
    -- Thunk the continuation
    -- Write this in the corresponding place in the threads structure
    let newThrs = <Console, RefState>(writeThk cur {k unit} readthrs) in
    write thrs newThrs;

    scheduleT newThk! next thrs;
    unit

-- If the thread ends, just force a yield.
scheduleT unit cur thrs = scheduleT yield! cur thrs


-- Finds the next highest ID in threads.
-- If there isn't one higher, i.e. the current is the max, finds the lowest.
nextId : {Int -> List Int -> Int}
nextId cur xs =
   let lgt = leastGT cur 100 xs in
   if (lgt == 100) -- i.e. cur is max
       { lowest 100 xs }
       { lgt }


----------------------------
-- Promise structures.

interface Promise  =
          promise R : Prom R [Promise, RefState, Yield] -> Pid R [Promise, RefState, Yield]
        | signal : Sig -> Unit
        | await R : Pid R [Promise, RefState, Yield]-> R

data Prom R  = printCb {String -> R}

----- REMEMBER TO ADD EQSIG
data Sig = printSig String

eqSig : {Sig -> Sig -> Bool}
eqSig (printSig _) (printSig _) = true
eqSig _ _ = false

----------------------------
-- Pids

data Pid X = pid (Ref (PromiseStatus X))

data PromiseStatus X = empty | done X | addRes {X ->  Unit}

readPid : {Pid X [E|] -> [RefState] PromiseStatus X [E|]}
readPid (pid cell) = read cell

writePid : {Pid X [E|] -> PromiseStatus X [E|] -> [RefState] Unit}
writePid (pid cell) x = write cell x

----------------------------
-- Threads

printer : {[Promise[Console], Yield, Console] Unit}
printer! = print "Printer starting\n";
           promise (printCb { x -> print "\n*- "; print x ; print "\n"});
           print "installed one\n";
           -- yield!;
           promise (printCb { x -> print "\n*- 2 "; print x ; print "\n"});
           print "installed two\n";
           -- yield!;
           promise (printCb { x -> print "\n*- 3 "; print x ; print "\n"});
           print "installed three\n";
           -- yield!;
           unit

printer2: {[Promise[Console], Yield, Console] Unit}
printer2! = print "Printer2 starting\n";
           promise (printCb { x -> print "*-"; print " Two! "; print x ; print "\n"});
           unit

sender : {[Promise[Console], Yield, Console]Unit}
sender! = print "Sender starting\n";
          signal (printSig "One");
          -- yield!;
          signal (printSig "Two");
          -- yield!;
          signal (printSig "Three");
          -- yield!;
          unit

catter : {[Console, Yield] Unit}
catter! = print "Beppy\n";
          sleep 200000;
          yield!;
          catter!
         

-- Utility for controller; breaks down a big sleeping chunk and yields inbetween.
sleepAndYield : Int -> [Console, Yield]Unit
sleepAndYield x = if (x < 0)
              { unit }
              { sleep 100000; yield!; sleepAndYield (x - 100000) }


----------------------------
-- Callback utilities

to_write : Pid R [E| RefState]-> {S -> [E| RefState]R} -> {S -> [E| RefState] Unit}
to_write (pid cell) cb = {x -> case (read cell)
                             { empty -> write cell (done (cb x))
                             | (addRes resumption) -> resumption (cb x)}}


prepPrint : {{String -> [E|]Unit} -> {Sig -> [E|] Unit}}
prepPrint cb = {s -> case (s)
                   { (printSig x) -> cb x
                   | _ -> unit}}

print_yield : {String -> [Console, Yield]Unit}
print_yield st = print st; print "\n";
                 sleep 250000;
                 yield!;
                 print_yield st


----------------------------
----- Handling Promises
----------------------------

hdl : {Int -> Ref (Threads [Console, Yield, RefState])
    -> <Promise[Console]> Unit
    -> [Yield, Console, RefState] Unit}

-- -- WTF
hdl thId thrs <promise (printCb cb) -> k> =
--     -- print "installing promise\n";
--     -- Create new pid cell
    print"prom in";
    let cell = pid (new empty) in
--     -- Process callback to convert to general form
    let cbMod = prepPrint (to_write cell cb) in

--     -- Handle callback alongside the rest of the computation.
    let cb3 = {sig rest -> { hdl thId thrs (cbMod sig; <Promise> rest!)}} in
    let readthrs = read thrs in
    let queued = <Console, RefState, Yield>(addCb thId cb3 readthrs) in
    -- let queued = (addCb thId cb3 readthrs) in

--     -- Write the resumption to the cell and resume.
    let res = {(hdl thId thrs (k cell))} in
    write thrs (<Console, Yield, RefState>(writeThk thId res queued));
    res!

-- So in this case, we want to go to each _thread_ and run the installed callbacks.
hdl thId thrs <signal sig -> thr> =
--     -- print "Executing signal\n";
--     -- update the threads w/ new signal
    print "sig in";
    let readthrs = read thrs in
    let newThrs = <Console, Yield, RefState>(runThreads sig (readthrs)) in

    let res = {hdl thId thrs (thr unit)} in
    write thrs (<Console, Yield, RefState>(writeThk thId res newThrs));
    res!

hdl thId thrs <await cell -> thr> =
    case (readPid cell)
         { (done x) ->
                 let readthrs = read thrs in
                 let res = {hdl thId thrs (thr x)} in
                 write thrs (<Console, RefState, Yield>(writeThk thId res readthrs));
                 res!
         -- thr2 has Fork in ambient, but addRes won't allow that.
         | empty -> writePid cell (addRes thr);
                 let readthrs = read thrs in
                 let res = {hdl thId thrs unit} in
                 write thrs (<Console, RefState, Yield>(writeThk thId res readthrs));
                 res!}

hdl thId thrs unit = unit

-------------------------------------
-- Running

-- emptyThrs : {Threads [Console, Yield, RefState]}
-- emptyThrs! = tnil

thr1 : {Ref (Threads [Console, Yield, RefState]) -> {[Console, Yield, RefState] Unit}}
thr1 thrs = {hdl 0 thrs (<RefState> printer!) }

thr2 : {Ref (Threads [Console, Yield, RefState]) -> {[Console, Yield, RefState] Unit}}
thr2 thrs = {hdl 1 thrs (<RefState> sender!) }

blankthrs : {[RefState] Ref (Threads [Console, Yield, RefState])}
blankthrs! = new tnil

-- progThrs : {[RefState] Ref (Threads [Console, Yield, RefState])}
-- progThrs! =
--     -- let thrs = new tnil in
--     let thrs = blankthrs! in
--     write thrs (tentry 0 (<RefState> (thr1 thrs)) (tq []) tnil);

-- --     write thrs (writeThk 0 (thr1 thrs) (read thrs));

-- --     -- write thrs (tentry 0 { hdl 0 thrs ( printer!) } (tq [])
-- --     --            (tentry 1 { hdl 1 thrs ( sender!) } (tq []) tnil));
--     thrs

addThrs : {Ref (Threads [Console, Yield, RefState]) -> [RefState] Unit}
addThrs thrs = write thrs (tentry 0 (<RefState> (thr1 thrs)) (tq [])
                          (tentry 1 (<RefState> (thr2 thrs)) (tq []) tnil))


run : {Ref (Threads [Console, Yield, RefState]) -> [Console, RefState]Unit}
run thrs =
    let readthrs = <Console>(read thrs) in
    let runner = <RefState, Console>(lookupThk 0 readthrs) in
    print "T";
    case runner
        { nothing -> unit
        | (just runner) -> (scheduleT (runner!) 0 thrs) };
    unit

hdled : {[Console, RefState]Unit}
hdled! =
    let thrs = <Console> blankthrs! in
    <Console> (addThrs thrs);
    run thrs
    -- let readthrs = (read thrs) in
    -- let runner = <RefState>(lookupThk 0 (readthrs)) in
    -- case runner
    --     { nothing -> unit
    --     | (just runner) -> let rMod = { runner!} in
    -- --                        -- (scheduleT (<Console(s a -> s a a)>(<RefState (s a -> s a a)> rMod!)) 0 (thrs))};
    --                         (scheduleT (( rMod!)) 0 (thrs))};
    -- unit



main : {[Console, RefState] Unit}
main! = hdled!
