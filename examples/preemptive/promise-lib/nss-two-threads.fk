include std

include threads_lib

---------------------
-- Scheduling

interface Yield = yield : Unit

-- ScheduleT schedules threads, but uses the threads structure for this.
scheduleT : {<Yield> Unit -> Int -> Ref Threads -> [Console, RefState]Unit}
scheduleT <yield -> k> cur thrs =
    -- Find which thread id is the next one to be ran.
    let readthrs = read thrs in
    let next = <Console, RefState> (nextId cur (keys readthrs)) in

    -- Look up this new thunk.
    let newThk = <Console, RefState>(fromMaybe (lookupThk next (readthrs))) in
    -- Thunk the continuation
    -- Write this in the corresponding place in the threads structure
    let newThrs = <Console, RefState>(writeThk cur {{k unit}} readthrs) in
    write thrs newThrs;

    -- Run the new thunk.
    let newMod = <Console, RefState> newThk! in
    scheduleT newMod! next thrs

-- If the thread ends, just force a yield.
scheduleT unit cur thrs = scheduleT yield! cur thrs

-- Finds the next highest ID in threads.
-- If there isn't one higher, i.e. the current is the max, finds the lowest.
nextId : {Int -> List Int -> Int}
nextId cur xs =
   let lgt = leastGT cur 100 xs in
   if (lgt == 100) -- i.e. cur is max
       { lowest 100 xs }
       { lgt }


----------------------------
-- Promise structures.

interface Promise  =
          promise R : Prom R [Promise, RefState, Yield] -> Pid R [Promise, RefState, Yield]
        | signal : Sig -> Unit
        | await R : Pid R [Promise, RefState, Yield] -> R

-- data Prom R  = printCb {String -> R}
data Prom R = prom {Sig -> R}

----- REMEMBER TO ADD EQSIG
data Sig = go Int | stop Int

----------------------------
-- Pids

data Pid X = pid (Ref (PromiseStatus X))

data PromiseStatus X = empty | done X | addRes {X ->  Unit}

readPid : {Pid X [E|] -> [RefState] PromiseStatus X [E|]}
readPid (pid cell) = read cell

writePid : {Pid X [E|] -> PromiseStatus X [E|] -> [RefState] Unit}
writePid (pid cell) x = write cell x

----------------------------
-- Threads

counter : {Int -> [Console, Yield]Unit}
counter x = ouint x; print " ";
            sleep 200000;
            yield!;
            counter (x + 1)

counter2 : {Int -> [Console, Yield]Unit}
counter2 x = ouch (toc x); print " ";
             sleep 200000;
             yield!;
             counter2 (x + 1)

goPromise : {Int -> Sig -> [Promise[Console], Console, Yield, RefState]Unit}
goPromise arity (go n) =
    -- if this message is for the current thread
    if ((mod n 2) == arity)
      -- just return unit
      { unit }
      -- else, reinstall and await.
      { await (promise (prom {s -> goPromise arity s})) }
goPromise arity _ = await (promise (prom {s -> goPromise arity s}))

stopPromise : {Int -> Sig -> [Promise[Console], Console, Yield, RefState]Unit}
stopPromise arity (stop n) =
   if ((mod n 2) == arity)
     -- When we receive stop, we stop; so we install go and
     -- block on it.
     { let gp = promise (prom {s -> goPromise arity s}) in
     await gp;
     -- Once go has been sent, we allow the thread to continue
     -- computing and reinstall the stop waiter.
     promise (prom {s -> stopPromise arity s}); unit}
     { promise (prom ({s -> stopPromise arity s})); unit }
stopPromise arity _ = await (promise (prom {s -> stopPromise arity s}))

waitForGo : {Int -> [Promise[Console], Console, RefState, Yield] Unit}
waitForGo arity =
    await (promise (prom {s -> goPromise arity s}));
    promise (prom {s -> stopPromise arity s});
    unit


thread1 : {[Promise[Console], Console, RefState, Yield] Unit}
thread1! = --promise (prom {s -> stopPromise 0 s});
           waitForGo 0;
           counter 0

thread2 : {[Promise[Console], Console, RefState, Yield] Unit}
thread2! = waitForGo 1;
           counter2 0

controller : {Int -> [Promise [Console], Console, RefState, Yield] Unit}
controller k = print "\n*- Stop "; ouint k; print "\n";
               signal (stop k);
               print "*- Go "; ouint (k + 1); print "\n";
               signal (go (k + 1));
               sleepAndYield 400000;
               controller (k + 1)

-- Utility for controller; breaks down a big sleeping chunk and yields inbetween.
sleepAndYield : Int -> [Console, Yield]Unit
sleepAndYield x = if (x < 0)
              { unit }
              { sleep 100000; yield!; sleepAndYield (x - 100000) }

print_yield : String -> [Console, Yield]Unit
print_yield str = print str; sleep 200000; yield!; print_yield str

----------------------------
-- Callback utilities

to_write : Pid R [E| RefState]-> {S -> [E| RefState]R} -> {S -> [E| RefState] Unit}
to_write (pid cell) cb = {x -> case (read cell)
                             { empty -> write cell (done (cb x))
                             | (addRes resumption) -> resumption (cb x)}}


----------------------------
----- Handling Promises
----------------------------

hdl : {Int -> Ref Threads
    -> <Promise[Console]> Unit
    -> [Yield, Console, RefState] Unit}

hdl thId thrs <promise (prom cb) -> k> =
    -- print "installing promise\n";
    -- Create new pid cell
    let cell = pid (new empty) in
    -- Process callback to convert to general form
    let cbMod = (to_write cell cb) in

    -- Handle callback alongside the rest of the computation.
    let cb3 = {sig rest -> { hdl thId thrs (cbMod sig; <Promise> rest!)}} in
    let readthrs = read thrs in
    let queued = <Console, RefState, Yield>(addCb thId cb3 readthrs) in

    -- Write the resumption to the cell and resume.
    let res = {{(hdl thId thrs (k cell))}} in
    write thrs (<Console, Yield, RefState>(writeThk thId res queued));
    (<Console, RefState, Yield> res!)!

-- So in this case, we want to go to each thread and run the installed callbacks.
hdl thId thrs <signal sig -> thr> =
    -- print "Executing signal\n";
    -- update the threads w/ new signal
    let readthrs = read thrs in
    let newThrs = <Console, Yield, RefState>(runThreads sig (readthrs)) in

    -- Yield to allow other threads to install promises
    -- This probs shouldn't be here?
    let res = {{yield!; hdl thId thrs (thr unit)}} in
    write thrs (<Console, Yield, RefState>(writeThk thId res newThrs));
    (<Console, RefState, Yield> res!)!

hdl thId thrs <await cell -> thr> =
    case (readPid cell)
         { (done x) ->
                 let readthrs = read thrs in
                 let res = {{hdl thId thrs (thr x)}} in
                 write thrs (<Console, RefState, Yield>(writeThk thId res readthrs));
                 (<Console, RefState, Yield> res!)!
         -- thr2 has Fork in ambient, but addRes won't allow that.
         | empty -> writePid cell (addRes thr);
                 let readthrs = read thrs in
                 let res = {{hdl thId thrs unit}} in
                 write thrs (<Console, RefState, Yield>(writeThk thId res readthrs));
                 (<Console, RefState, Yield> res!)!}

hdl thId thrs unit = unit

-- -------------------------------------
-- -- Running


hdled : {[Console, RefState]Unit}
hdled! =
    let thrs = new (tnil) in
    write thrs (tentry 0 {{ hdl 0 thrs (controller 0) }} (tq [])
               (tentry 1 {{ hdl 1 thrs (thread2!) }} (tq [])
               ((tentry 2 {{ hdl 2 thrs (thread1!) }} (tq []) tnil))));



    let readthrs = read thrs in
    let runner = <Console, RefState>(lookupThk 0 (readthrs)) in
    case runner
        { nothing -> unit
        | (just runner) -> scheduleT ((<Console, RefState, Yield> runner!)!) 0 (thrs)}


-- Three threads, printing out cat names.
-- cats : {[Console]Unit}
-- cats! = scheduleQ ( print_yield "Beppy" )
--                   ( enqueue 1 { print_yield "Botsman" } (
--                            enqueue 2 { print_yield "Timmy"} qnil!
                                -- ) )
cats : {[Console, RefState] Unit}
cats! =
    let thrs = new (tentry 0 {{ <RefState> (print_yield "Beppy") }} (tq [])
                   (tentry 1 {{ <RefState> (print_yield "Botsman") }} (tq [])
                   (tentry 2 {{ <RefState> (print_yield "Timmy") }} (tq []) tnil))) in

    let readthrs = read thrs in
    let runner = <Console, RefState> (lookupThk 0 readthrs) in
    case runner
        { nothing -> unit
        | (just runner) -> scheduleT (runner!)! 0 thrs}

main : {[Console, RefState] Unit}
main! = cats!
