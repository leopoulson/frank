include std

include map

include helpers_cb

-- Promise interface
interface Promise =
          promise R : Prom R [Promise, RefState] -> Pid R
        | signal : Sig -> Unit
        | await R : Pid R -> R

interface Tick = tick : Unit

data Prom R [E] = nextCb {Unit -> [E|] R}
                | requestCb {Int -> [E|] R}
                | responseCb {Int -> [E|] R}

-- TODO: Change this to be labels; so that it's op S Int?
data Sig = nextSig Unit | requestSig Int | responseSig Int


-- equality between signals
eqSig : {Sig -> Sig -> Bool}
eqSig (requestSig _) (requestSig _) = true
eqSig (responseSig _) (responseSig _) = true
eqSig (nextSig _) (nextSig _) = true
eqSig _ _ = false

data Pid X = pid (Ref (Maybe X))

readPid : {Pid X -> [RefState] (Maybe X)}
readPid (pid cell) = read cell

-- Given a pid and a callback, rewrites the callback such that it writes the
-- result to the cell and returns unit, whilst still performing effects as before.
-- Adds RefState to the ambient in the promise.
to_write : Pid R -> {S -> [E| RefState]R} -> {S -> [E| RefState] Unit}
to_write (pid cell) cb = {x -> let res = (cb x) in
                               write cell (just res)}

-- Converts a function of Int -> Unit to one of Sig -> unit.
prep_next : {{Unit -> [E|]Unit} -> {Sig -> [E|]Unit}}
prep_next cb = {s -> case (s)
                    { (nextSig x) -> cb x
                    | _ -> unit}}

prep_req : {{Int -> [E|]Unit} -> {Sig -> [E|]Unit}}
prep_req cb = {s -> case (s)
                    { (requestSig x) -> cb x
                    | _ -> unit}}

prep_resp : {{Int -> [E|]Unit} -> {Sig -> [E|]Unit}}
prep_resp cb = {s -> case (s)
                    { (responseSig x) -> cb x
                    | _ -> unit}}

----------------------
-- Thread code
--

client : {[Promise [Console], Console, RefState]Unit}
client! = promise (nextCb
     {_ -> print "oops!\n";
           let cell = new nothing in
           signal (requestSig 10);
           promise (responseCb {x -> print "response! "; ouint x; print "\n"; write cell (just x)});
           client!})
    ; unit

-- waits for a request, sends input + 10, reinstalls itself.
requestWaiter : {Int -> [Console, Promise [Console], RefState] Unit}
requestWaiter x = print "request\n";
                  signal (responseSig (x + 10));
                  promise (requestCb requestWaiter);
                  unit

-- server just installs the repsonse promise which reinstalls itself once it's been used.
server : {[Promise [Console]]Unit}
server! = promise (requestCb requestWaiter); unit

user : {[Console, Promise [Console]] Unit}
user! = inch!;
        signal (nextSig unit); user!

-----------------------
-- Handler / scheduler

-- Datatype for the map of signatures to callbacks, etc
-- hdl : {Map Sig (List {Sig -> [Promise [Console], Console, RefState]Unit})  -- callbacks
-- The integer in the pair is the 'index' of the callback, i.e. which thread it was issued on.
data Callbacks [E] = callbacks (Map Sig (List (Pair Int {Sig -> [E|]Unit})))

maybeApply : {Int -> Int -> {[E|]Unit} -> {[E|]R} -> {[E|]R}}
maybeApply cbId threadId callback thread =
    if (cbId == threadId)
     {{callback!; thread!}}
     {thread}

hdl : {Callbacks [Promise [Console], Console, RefState]  --callbacks, parametrised by effects
    -> <Promise [Console]> Unit -- server
    -> <Promise [Console]> Unit -- client
    -> <Promise [Console]> Unit -- user
    -> [Console, RefState] Unit}

-- Installing promises
-- cbMod is the original callback, modified to make its input and return types generic.
hdl cbs <promise (requestCb cb) -> server> <client> <user> =
    let cell = pid (new nothing) in
    let cbMod = (prep_req (to_write cell cb)) in
    hdl (snocOrInsert (requestSig 0) (pair 0 cbMod) cbs) (server cell) client! user!

hdl cbs <server> <promise (nextCb cb) -> client> <user> =
    let cell = pid (new nothing) in
    let cbMod = (prep_next (to_write cell cb)) in
    hdl (snocOrInsert (nextSig unit) (pair 1 cbMod) cbs) server! (client cell) user!

hdl cbs <server> <promise (responseCb cb) -> client> <user> =
    let cell = pid (new nothing) in
    let cbMod = (prep_resp (to_write cell cb)) in
    hdl (snocOrInsert (responseSig 0) (pair 1 cbMod) cbs) server! (client cell) user!

hdl cbs <signal sig -> server> <client> <user> =
    -- Look to see if there's any promises of this type waiting.
    case (peek sig cbs)
      -- if not, do nothing and return.
      { nothing -> hdl cbs (server unit) client! user!
      -- if there is, run it on the source thread.
      | (just (pair id cb)) -> hdl (pop sig cbs)
                                   ((maybeApply id 0 {cb sig} {server unit})!)
                                   ((maybeApply id 1 {cb sig} client)!)
                                   ((maybeApply id 2 {cb sig} user)!)}

hdl cbs <server> <signal sig -> client> <user> =
    -- Look to see if there's any promises of this type waiting.
    case (peek sig cbs)
      -- if not, do nothing and return.
      { nothing -> hdl cbs server! (client unit) user!
      -- if there is, run it on the source thread.
      | (just (pair id cb)) -> hdl (pop sig cbs)
                                   ((maybeApply id 0 {cb sig} server)!)
                                   ((maybeApply id 1 {cb sig} {client unit})!)
                                   ((maybeApply id 2 {cb sig} user)!)}

-- Processing incoming signals without blocked computation.
hdl cbs <server> <client> <signal sig -> user> =
    -- Look to see if there's any promises of this type waiting.
    case (peek sig cbs)
      -- if not, do nothing and return.
      { nothing -> hdl cbs server! client! (user unit)
      -- if there is, run it on the source thread.
      | (just (pair id cb)) -> hdl (pop sig cbs)
                                   ((maybeApply id 0 {cb sig} server)!)
                                   ((maybeApply id 1 {cb sig} client)!)
                                   ((maybeApply id 2 {cb sig} {user unit})!)}


-- -- Processing incoming signals with blocked comp.
-- hdl cbs (just (pair cell resumption)) unit <signal sig -> client> =
--     -- If there's no callbacks of this type to run, just don't do anything.
--     case (peek sig cbs)
--      { nothing -> hdl cbs (just (pair cell resumption)) unit (client unit)
--      | (just cb) ->
--        -- First run the callback.
--        let cbResult = cb sig in
--        -- Then remove it from storage.
--        let poppedCbs = pop sig cbs in
--        -- Then check if the cell has had a value put in it as a result.
--        case (readPid cell)
--           -- if we have a result, apply whatever the result of the comp is and then resume
--           { (just result) -> hdl poppedCbs nothing (cbResult; resumption result) (client unit)
--           -- if we do not, just try again
--           | nothing -> hdl poppedCbs (just (pair cell resumption)) unit (client unit)}}

-- hdl cbs res <await cell -> server> <client> =
--     case (readPid cell)
--       { (just x) -> print "straight through\n"; hdl cbs nothing (server x) client!
--       | nothing  -> hdl cbs (just (pair cell server)) unit client! }

hdl _ unit _ _ = unit
hdl _ _ unit _ = unit
hdl _ _ _ unit = unit

main : {[Console, RefState] Unit}
main! = hdl (callbacks mnil) (<RefState, Console>(server!)) ((client!)) (<RefState>(user!))
