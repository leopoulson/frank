include std

include callbacks

----------------
-- Coroutines

-- Just use fork to make a new thread.
interface Fork = fork    : {[Fork, Yield]Unit} -> Unit
               -- This essentially HAS to have this type.
               | onOther  : {{[Queue Proc]Unit} -> [Fork, Yield, Queue Proc]Unit} -> Unit
               | execOther : {[Fork, Yield, Queue Proc]Unit} -> Unit

interface Yield = yield : Unit

data Proc = proc {[Queue Proc]Unit}

enqProc : {[Queue Proc]Unit} -> [Queue Proc]Unit
enqProc p = enqueue (proc p)

runNext : {[Queue Proc]Unit}
runNext! = case dequeue! { (just (proc x)) -> x!
                         | nothing         -> unit }

-- defer forked processes
-- scheduleBF : {<Fork, Yield>Unit -> [Queue Proc]Unit}
-- scheduleBF <yield -> k>  = enqProc {scheduleBF (k unit)};
--                            runNext!
-- scheduleBF <fork p -> k> = enqProc {scheduleBF (<Queue> p!)};
--                            scheduleBF (k unit)
-- scheduleBF unit          = runNext!

-- eagerly run forked processes
scheduleDF : {<Fork, Yield>Unit -> [Queue Proc]Unit}
scheduleDF <yield -> k>  = enqProc {scheduleDF (k unit)};
                           runNext!
scheduleDF <fork p -> k> = enqProc {scheduleDF (k unit)};
                           scheduleDF (<Queue> p!)

-- handling on-other
scheduleDF <onOther f -> k> =
    case dequeue!
         { nothing -> unit
         | (just (proc x)) ->
         -- so the other thread is in x.
         -- enqueue it back, w/ the function applied.
                 -- let cont = {(f x)} in
                 -- enqProc { (scheduleDF ((f x))) };
                 enqProc { scheduleDF ((f x)) };
                 unit
                 };
    -- defer that and lazily resume.
    scheduleDF (k unit)


-- scheduleDF <execOther t -> k> =
--     case dequeue!
--          { nothing -> unit
--          | (just (proc x)) ->
--          -- so the other thread is in x.
--          -- enqueue it back, w/ the thunk t applied first.
--                  -- let cont = {<Queue>(f x)} in
--                  -- let cont = { ((t!) ; (x!)) } in
--                  enqProc { scheduleDF (t!; <Yield, Fork>(x!)) };
--                  unit
--                  };
--     -- defer that and lazily resume.
--     scheduleDF (k unit)

scheduleDF unit          = runNext!

-- schedule by just immediately running forked thread
-- scheduleNow : {<Fork[E|]>Unit -> [E|]Unit}
-- -- scheduleNow <yield -> k>  = scheduleNow (k unit)
-- scheduleNow <fork p -> k> = scheduleNow (p!; k unit)
-- scheduleNow unit          = unit

--------------------------------------------------------------------------------
-- Queue interface and implementation
--------------------------------------------------------------------------------

interface Queue S = enqueue : S -> Unit
                  | dequeue : Maybe S

-- FIFO queue implementation using a zipper
fq : {List S -> List S -> <Queue S>X -> X}
fq front        back <enqueue x -> k> = fq front (x :: back) (k unit)
fq []           []   <dequeue -> k>   = fq [] [] (k nothing)
fq []           back <dequeue -> k>   = fq (reverse back) [] (k dequeue!)
fq (x :: front) back <dequeue -> k>   = fq front back (k (just x))
fq front        back x                = x

fifo : {<Queue S>X -> X}
fifo <m> = fq [] [] m!

runDF : {<Fork, Yield> Unit -> Unit}
runDF <m> = fifo (scheduleDF (<Queue> m!))

----------------------------
-- Promise structures.

interface Promise =
          promise R : Prom R [Promise, RefState, Yield] -> Pid R [Promise, RefState, Yield]
        | signal : Sig -> Unit
        | await R : Pid R [Promise, RefState, Yield]-> R

data Prom R [E] = goCb {Unit -> [E|] R}
                | stopCb {Unit -> [E|] R}

data Sig = goSig Unit | stopSig Unit

eqSig : {Sig -> Sig -> Bool}
eqSig (goSig _) (goSig _) = true
eqSig (stopSig _) (stopSig _) = true
eqSig _ _ = false


----------------------------
-- Pids

data Pid X = pid (Ref (PromiseStatus X))

data PromiseStatus X = empty | done X | addRes {X -> Unit}

readPid : {Pid X [E|] -> [RefState] PromiseStatus X [E|]}
readPid (pid cell) = read cell

writePid : {Pid X [E|] -> PromiseStatus X [E|] -> [RefState] Unit}
writePid (pid cell) x = write cell x

----------------------------
-- Threads

counter : {Int -> [Console, Yield]Unit}
counter x = ouint x; print " ";
            sleep 200000;
            yield!;
            counter (x + 1)

-- Install an interrupt handler for stopping.
waitForStop : {[Console, Promise[Console], RefState, Yield] Pid Unit [Console, Promise[Console], RefState, Yield]}
waitForStop! =
    promise (stopCb { _ ->
                       -- When we receive stop, we stop; so we install go and
                       -- block on it.
                       print "Stop msg received\n";
                       let goPromise = promise (goCb {_ -> unit}) in
                       await goPromise;
                       -- Once go has been sent, we allow the thread to continue
                       -- computing and reinstall the stop waiter.
                       waitForStop!;
                       unit})

sleepAndYield : Int -> [Console, Yield]Unit
sleepAndYield x = if (x < 0)
              { unit }
              { sleep 100000; yield!; sleepAndYield (x - 100000) }

thread1 : {[Promise[Console], Console, RefState, Yield] Unit}
thread1! = print "starting"; waitForStop!; counter 0

controller : {[Promise [Console], Console, RefState, Yield] Unit}
controller! = print "\n*- Stop\n"; signal (stopSig unit);
              sleepAndYield 400000;
              print "\n*- Go\n"; signal (goSig unit);
              sleepAndYield 400000;
              controller!

----------------------------
-- -- Callback utilities

to_write : Pid R [E| RefState]-> {S -> [E| RefState]R} -> {S -> [E| RefState] Unit}
to_write (pid cell) cb = {x -> case (read cell)
                             { empty -> write cell (done (cb x))
                             | (addRes resumption) -> resumption (cb x)}}

prepStop : {{Unit -> [E|] Unit} -> {Sig -> [E|] Unit}}
prepStop cb = {s -> case (s)
                   { (stopSig x) -> cb x
                   | _ -> unit}}

prepGo : {{Unit -> [E|] Unit} -> {Sig -> [E|] Unit}}
prepGo cb = {s -> case (s)
                   { (goSig x) -> cb x
                   | _ -> unit}}

apply : {Int -> Int -> {[E|]Unit} -> {[E|]R} -> {[E|]R}}
apply cbId threadId callback thread =
    if (cbId == threadId)
     {{callback!; thread!}}
     {thread}

----------------------------
-- Handler


hdl : {Ref (Callbacks [Console, Promise [Console], RefState, Yield])
    -> <Fork| Promise[Console]> Unit  -- thread, which can't Fork.
    -> [Fork[Console, RefState], Yield, Console, RefState] Unit}

-- Installing Promises
hdl cbs <promise (stopCb cb) -> th1> =
    -- Create new pid cell
    let cell = pid (new empty) in
    -- Process callback to convert to correct form
    let cbMod = prepStop (to_write cell cb) in
    -- Add to list and resume.
    write cbs (snocOrInsert (stopSig unit) (pair 0 cbMod) (read cbs));
    hdl cbs (th1 cell)

hdl cbs <promise (goCb cb) -> th1>  =
    let cell = pid (new empty) in
    let cbMod = prepGo (to_write cell cb) in
    write cbs (snocOrInsert (goSig unit) (pair 0 cbMod) (read cbs));
    hdl cbs (th1 cell)

------ Executing promises based on signals.
hdl cbs <signal sig -> thr> =
    -- Look to see if there's any matching promises waiting.
    case (peek sig (read cbs))
    -- If there isn't, do nothing and carry on.
      { nothing -> hdl cbs (thr unit)
      -- If there is, pop them, then fork off the promise to be run.
      | (just (pair id cb)) ->
              write cbs (pop sig (read cbs));

              -- fork { hdl cbs (cb sig) };
              -- Here we need to say, run the callback on the other one.
              -- onOther { x -> ((x!)) };
              fork { hdl cbs (cb sig) };
              -- onOther { x -> <Queue>(hdl cbs (cb sig)); (x!) };
              -- onOther { x ->  <Queue>(hdl cbs (print "yes"; (x!); unit))  };
              -- execOther { <Queue>(hdl cbs (cb sig)) };
              -- execOther { <Queue>(print "hey") };

              hdl cbs (thr unit)}

hdl cbs <await cell -> thr> =
    case (readPid cell)
         { (done x) -> hdl cbs (thr x)
         | empty -> writePid cell (addRes thr);
                    hdl cbs unit}
                   
hdl _ unit = unit


hdled : {[Console, RefState, Fork[Console, RefState], Yield] Unit}
hdled! = let cbs = new cbnil in
         fork { hdl cbs thread1! };
         fork { hdl cbs controller! };
         unit

main : {[Console, RefState]Unit}
main! = runDF hdled!
