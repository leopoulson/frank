--- start of standard stuff ---

data Pair X Y = pair X Y

fst : Pair X Y -> X
fst (pair x _) = x

snd : Pair X Y -> Y
snd (pair _ y) = y

data Trio X Y Z = trio X Y Z

fstT : Trio X Y Z -> X
fstT (trio x _ _) = x

sndT : Trio X Y Z -> Y
sndT (trio _ y _) = y

thdT : Trio X Y Z -> Z
thdT (trio _ _ z) = z

data Maybe X = nothing | just X


-- -- unsafe, obviously
fromMaybe : {Maybe X -> X}
fromMaybe (just x) = x

map : {{X -> Y} -> List X -> List Y}
map f []        = []
map f (x :: xs) = f x :: map f xs

print : {String -> [Console]Unit}
print s = map ouch s; unit

-- lazy conditional
if : {Bool -> {X} -> {X} -> X}
if true  t f = t!
if false t f = f!

while : {Bool} -> {Unit} -> Unit
while cond body = if cond! { body!; while cond body }
                            { unit }



and : {Bool -> Bool -> Bool}
and true  y = y
and false _ = false

not : Bool -> Bool
not true = false
not false = true

take : {Int -> List X -> List X}
take 0 _ = nil
take k (cons x xs) = cons x (take (k - 1) xs)

drop : {Int -> List X -> List X}
drop 0 xs = xs
drop k nil = nil
drop k (cons x xs) = drop (k - 1) xs

range : Int -> Int -> List Int
range from to = if (from == to)
                   {nil}
                   {cons from (range (from + 1) to)}

nth : {Int -> List X -> X}
nth 0 (cons s _)  = s
nth k (cons _ xs) = nth (k - 1) xs

len : {List X -> Int}
len nil = 0
len (cons _ xs) = 1 + len xs

concat : {List X -> List X -> List X}
concat nil ys = ys
concat (cons x xs) ys = cons x (concat xs ys)


snoc : {List X -> X -> List X}
snoc nil x = [x]
snoc (y :: ys) x = y :: (snoc ys x)


reverse' : {List X -> List X -> List X}
reverse' []        ys = ys
reverse' (x :: xs) ys = reverse' xs (x :: ys)

reverse : {List X -> List X}
reverse xs = reverse' xs []

mplus : Int -> Maybe Int -> Maybe Int
mplus _ nothing = nothing
mplus x (just y) = just (x + y)

putIn : X -> Int -> List X -> List X
putIn _ _ [] = []
putIn x 0 (_ :: ys) = x :: ys
putIn x k (y :: ys) = y :: (putIn x (k - 1) ys)

findFree : List (Maybe Int) -> Maybe Int
findFree [] = nothing
findFree (nothing :: xs) = just 0 --mplus 1 (findFree xs)
findFree ((just _) :: xs) = mplus 1 (findFree xs)

lookupCall : Int -> List (Maybe Int) -> Maybe Int
lookupCall _ [] = nothing
lookupCall x (nothing :: ys) = mplus 1 (lookupCall x ys)
lookupCall x ((just y) :: ys) = if (x == y) { just 0 } { mplus 1 (lookupCall x ys) }
--- end of standard stuff ---

mul : Int -> Int -> Int
mul x 0 = 0
mul x y = x + mul x (y - 1)

fold : {X -> Y -> Y} -> Y -> List X -> Y
fold f e nil = e
fold f e (x :: xs) = f x (fold f e xs)

lowest : {Int -> List Int -> Int}
lowest x [] = x
lowest x (y :: ys) =
    if ( y < x )
        { lowest y ys }
        { lowest x ys }

leastGT : {Int -> Int -> List Int -> Int}
leastGT orig best [] = best
leastGT orig best (x :: xs) =
    if (and (orig < x) (x < best))
        { leastGT orig x xs }
        { leastGT orig best xs }



leq : Int -> Int -> Bool
leq x y = if (x == y)
            {true}
            {x < y}

mod : Int -> Int -> Int
mod a m = if (leq m a)
             {mod (a - m) m}
             {a}

toc : Int -> Char
toc x = toc2 (mod x 7)

toc2 : Int -> Char
toc2 0 = 'a'
toc2 1 = 'b'
toc2 2 = 'c'
toc2 3 = 'd'
toc2 4 = 'e'
toc2 5 = 'f'
toc2 6 = 'g'
