include std

include threads_lib

---------------------
-- Scheduling

interface Yield = yield : Unit

-- -- ScheduleT schedules threads, but uses the threads structure for this.
scheduleT : {<Yield> Unit -> Int -> Ref (Threads [Console, PrintOp, RefState, Yield]) -> [Console, PrintOp, RefState]Unit}
scheduleT <yield -> k> cur thrs =
    -- Find which thread id is the next one to be ran.
    let readthrs = read thrs in
    let next = <Console, RefState, PrintOp> (nextId cur (keys readthrs)) in

    -- Look up this new thunk.
    let newThk = <Console, RefState, PrintOp>(fromMaybe (lookupThk next (readthrs))) in
    -- Thunk the continuation
    -- Write this in the corresponding place in the threads structure
    let newThrs = <Console, RefState, PrintOp>(writeThk cur {k unit} readthrs) in
    write thrs newThrs;

    scheduleT newThk! next thrs;
    unit

-- If the thread ends, just force a yield.
scheduleT unit cur thrs = scheduleT yield! cur thrs


-- Finds the next highest ID in threads.
-- If there isn't one higher, i.e. the current is the max, finds the lowest.
nextId : {Int -> List Int -> Int}
nextId cur xs =
   let lgt = leastGT cur 100 xs in
   if (lgt == 100) -- i.e. cur is max
       { lowest 100 xs }
       { lgt }


----------------------------
-- Promise structures.

interface Promise [E] =
          promise R : Prom R [E | Promise[E|], RefState, Yield] -> Pid R [E | Promise[E|], RefState, Yield]
        | signal : Sig -> Unit
        | await R : Pid R [E | Promise[E|], RefState, Yield]-> R

-- Any effects will be performed in the returned comp.
-- Any guard conditions should NOT have effects in.
data Prom R [E] = prom {Sig -> Maybe {[E|]R}}

data Sig = printSig String | intSig Int

interface PrintOp = printOp : Unit

interface IntOp = intOp : Unit

----------------------------
-- Pids

data Pid X = pid (Ref (PromiseStatus X))

data PromiseStatus X = empty | done X | addRes {X -> Unit}

readPid : {Pid X [E|] -> [RefState] PromiseStatus X [E|]}
readPid (pid cell) = read cell

writePid : {Pid X [E|] -> PromiseStatus X [E|] -> [RefState] Unit}
writePid (pid cell) x = write cell x

----------------------------
-- Threads

first : {Sig -> Maybe {[Promise[Console, PrintOp], Console, PrintOp, RefState, Yield] Unit}}
first (printSig x) = just {printOp!; print "\n *- First "; print x}
first _ = nothing

intProm : {Sig -> Maybe {[Promise[Console, IntOp], Console, IntOp, RefState, Yield] Unit}}
intProm (intSig x) = just {intOp!; print "\n *- Int Msg "; ouint x}
intProm _ = nothing

firstClean : {Sig -> Maybe {[Promise[Console], Console, RefState, Yield] Unit}}
firstClean (printSig x) = just {print "\n *- FirstClean "; print x}
firstClean _ = nothing

printer : {[Promise[Console, PrintOp], Yield, Console] Unit}
printer! = print "Printer starting\n";
           promise (prom first);
           unit

inter : {[Promise[Console, IntOp], Yield, Console] Unit}
inter! = print "Printer starting\n";
           promise (prom intProm);
           unit

-- This guy sends both types of message.
sender : {[Promise[Console, PrintOp], Promise[Console, IntOp],  Yield, Console]Unit}
sender! = print "Sender starting\n";
          signal (printSig "One");
          signal (intSig 1);
          unit

catter : {[Console, Yield] Unit}
catter! = print "Beppy\n";
          sleep 200000;
          yield!;
          catter!
         

-- Utility for controller; breaks down a big sleeping chunk and yields inbetween.
sleepAndYield : Int -> [Console, Yield]Unit
sleepAndYield x = if (x < 0)
              { unit }
              { sleep 100000; yield!; sleepAndYield (x - 100000) }


----------------------------
-- Callback utilities

to_writeM2 : Pid R [E|RefState]
          -> {S -> (Maybe {[E|RefState] R})}
          -> {S -> (Maybe {[E|RefState] Unit})}
to_writeM2 (pid cell) cb =
    {x -> case (cb x)
         { nothing -> nothing
         | (just susp) ->
             just {case (read cell)
                      { empty -> write cell (done susp!)
                      | (addRes resumption) -> resumption susp!}} }}


print_yield : {String -> [Console, Yield]Unit}
print_yield st = print st; print "\n";
                 sleep 250000;
                 yield!;
                 print_yield st


----------------------------
----- Handling Promises
----------------------------

hdlPr : {Int -> Ref (Threads [Console, PrintOp, Yield, RefState])
    -> <Promise[Console, PrintOp]> Unit
    -> [Yield, Console, PrintOp, RefState] Unit}

-- hdlPr thId thrs <promise (prom cb) -> k> =
--     -- Create new pid cell
--     let cell = pid (new empty) in
--     -- Process callback to convert to general form
--     let cbMod = <Console, PrintOp, RefState, Yield>(to_writeM2 cell cb) in

--     -- Handle callback alongside the rest of the computation.
--     let cbMaybe = {sig rest -> (case (cbMod sig)
--                                    { nothing -> nothing
--                                    | (just susp) -> just { (hdlPr thId thrs (susp!; <Promise> rest!)) } })} in

--     let readthrs = read thrs in
--     let queued = <Console, PrintOp, RefState, Yield>(addCb thId (cbMaybe) readthrs) in

--     -- Write the resumption to the cell and resume.
--     let res = {(hdlPr thId thrs (k cell))} in
--     write thrs (<Console, PrintOp, Yield, RefState>(writeThk thId res queued));
--     res!

-- -- So in this case, we want to go to each _thread_ and run the installed callbacks.
-- hdlPr thId thrs <signal sig -> thr> =
--     let readthrs = read thrs in
--     let newThrs = <Console, PrintOp, Yield, RefState>(runThreads sig (readthrs)) in

--     let res = {hdlPr thId thrs (thr unit)} in
--     write thrs (<Console, PrintOp, Yield, RefState>(writeThk thId res newThrs));
--     res!

-- hdlPr thId thrs <await cell -> thr> =
--     let readthrs = read thrs in
--     let res = new {} in
--     case (readPid cell)
--          { (done x) ->
--                  write res {hdlPr thId thrs (thr x)}
--          -- thr2 has Fork in ambient, but addRes won't allow that.
--          | empty ->
--                  writePid cell (addRes thr);
--                  write res {hdlPr thId thrs unit}};
--     let readres = read res in
--     write thrs (<Console, PrintOp, RefState, Yield> (writeThk thId readres readthrs));
--     readres!

-- hdlPr thId thrs unit = unit


hdlInt : {Int -> Ref (Threads [Console, PrintOp, IntOp, Yield, RefState])
    -> <PrintOp | Promise[Console, IntOp]> Unit
    -> [Yield, Console, IntOp, RefState] Unit}

hdlInt thId thrs <promise (prom cb) -> k> =
    -- Create new pid cell
    let cell = pid (new empty) in
    -- Process callback to convert to general form
    let cbMod = <Console, PrintOp, IntOp, RefState, Yield>(to_writeM2 cell cb) in

    -- Handle callback alongside the rest of the computation.
    let cbMaybe = {sig rest -> (case (cbMod sig)
                                   { nothing -> nothing
                                   | (just susp) -> just { (hdlInt thId thrs ( susp!; <Promise> rest!)) } })} in

    let readthrs = read thrs in --
    let queued = <Console, IntOp, RefState, Yield>(addCb thId (cbMaybe) readthrs) in

    -- -- Write the resumption to the cell and resume.
    -- let res = {(hdlInt thId thrs (k cell))} in
    -- write thrs (<Console, PrintOp, IntOp, Yield, RefState>(writeThk thId res queued));
    -- res!
    unit

-- -- So in this case, we want to go to each _thread_ and run the installed callbacks.
-- hdlInt thId thrs <signal sig -> thr> =
--     let readthrs = read thrs in
--     let newThrs = <Console, PrintOp, IntOp, Yield, RefState>(runThreads sig (readthrs)) in

--     let res = {hdlInt thId thrs (thr unit)} in
--     write thrs (<Console, PrintOp, IntOp, Yield, RefState>(writeThk thId res newThrs));
--     res!

-- hdlInt thId thrs <await cell -> thr> =
--     let readthrs = read thrs in
--     let res = new {} in
--     case (readPid cell)
--          { (done x) ->
--                  write res {hdlInt thId thrs (thr x)}
--          -- Problem here is that thr has PrintOp in the ambient, but
--          | empty ->
--                  writePid cell (addRes {x -> <PrintOp> (thr x)});
--                  write res {hdlInt thId thrs unit}};
--     -- let readres = read res in
--     -- write thrs (<Console, PrintOp, IntOp, RefState, Yield> (writeThk thId readres readthrs));
--     -- readres!
--     unit

-- hdlInt thId thrs unit = unit

-------------------------------------
-- Running

-- thr1 : {Ref (Threads [Console, PrintOp, IntOp, Yield, RefState]) -> {[Console, PrintOp, Yield, RefState] Unit}}
-- thr1 thrs = {hdlPr 0 thrs (<RefState, PrintOp> printer!) }

-- thr2 : {Ref (Threads [Console, PrintOp, IntOp, Yield, RefState]) -> {[Console, PrintOp, IntOp, Yield, RefState] Unit}}
-- thr2 thrs = {hdlPr 1 thrs (<RefState, PrintOp> sender!) }

-- -- All of these RefState adaptors are necessary, unfortunately.
-- makeThreads : {[RefState] Ref (Threads [Console, PrintOp, Yield, RefState])}
-- makeThreads! =
--     let thrs = new tnil in
--     write thrs (tentry 0 (<RefState> (thr1 thrs)) (tq [])
--                (tentry 1 (<RefState> (thr2 thrs)) (tq []) tnil));
--     thrs


-- run : {Ref (Threads [Console, PrintOp, Yield, RefState]) -> [Console, PrintOp, RefState]Unit}
-- run thrs =
--     let readthrs = <Console, PrintOp>(read thrs) in
--     let runner = <RefState, Console, PrintOp>(lookupThk 0 readthrs) in
--     case runner
--         { nothing -> unit
--         | (just runner) -> scheduleT runner! 0 thrs };
--     unit

-- removePrint : {<PrintOp> Unit -> Unit}
-- removePrint <printOp -> k> = removePrint (k unit)
-- removePrint unit = unit

-- hdled : {[Console, RefState]Unit}
-- hdled! =
--     let thrs = <Console> makeThreads! in
--     removePrint (run thrs)

-- main : {[Console, RefState] Unit}
-- main! = hdled!
