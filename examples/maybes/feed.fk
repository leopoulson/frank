include std

include tl_typed

---------------------
-- Scheduling

interface Yield = yield : Unit

-- -- ScheduleT schedules threads, but uses the threads structure for this.
scheduleT : {<Yield> Unit -> Int -> Ref (Threads S [Console, RefState, Yield]) -> [Console, RefState]Unit}
scheduleT <yield -> k> cur thrs =
    -- Find which thread id is the next one to be ran.
    let readthrs = read thrs in
    let next = <Console, RefState> (nextId cur (keys readthrs)) in

    -- Look up this new thunk.
    let newThk = <Console, RefState>(fromMaybe (lookupThk next (readthrs))) in
    -- Thunk the continuation
    -- Write this in the corresponding place in the threads structure
    let newThrs = <Console, RefState>(writeThk cur {k unit} readthrs) in
    write thrs newThrs;

    scheduleT newThk! next thrs;
    unit

-- If the thread ends, just force a yield.
scheduleT unit cur thrs = scheduleT yield! cur thrs


-- Finds the next highest ID in threads.
-- If there isn't one higher, i.e. the current is the max, finds the lowest.
nextId : {Int -> List Int -> Int}
nextId cur xs =
   let lgt = leastGT cur 100 xs in
   if (lgt == 100) -- i.e. cur is max
       { lowest 100 xs }
       { lgt }


----------------------------
-- Promise structures.

interface Promise S [E] =
          promise R : IH S R [E | Promise S [E|], RefState, Yield]
                   -> Prom R [E | Promise S [E|], RefState, Yield]
        | signal : S -> Unit
        | await R : Prom R [E | Promise S [E|], RefState, Yield] -> R

-- Any effects will be performed in the returned comp.
-- Any guard conditions should NOT have effects in.
-- data ih R [E] = ih {Sig -> Maybe {[E|]R}}

data IH S R [E] = ih {S -> Maybe {[E|] R}}

data Feed = nextItem | newData Int | response (List Int) | display Int

----------------------------
-- Pids

data Prom X = prom (Ref (PromiseStatus X))

data PromiseStatus X = empty | done X | addRes {X -> Unit}

readPid : {Prom X [E|] -> [RefState] PromiseStatus X [E|]}
readPid (prom cell) = read cell

writePid : {Prom X [E|] -> PromiseStatus X [E|] -> [RefState] Unit}
writePid (prom cell) x = write cell x

----------------------------
-- Threads

head : List Int -> Int
head [] = -1
head (x :: xs) = x

pop : List Int -> List Int
pop [] = []
pop (x::xs) = xs

last : List Int -> Int
last [] = -1
last (x::[]) = x
last (x :: (y :: ys)) = last (y :: ys)

interface InThread = [Promise Feed [Console], Console, RefState, Yield]

displayRestart : {List Int -> Maybe (Prom (List Int) [InThread]) -> [InThread] Unit}
displayRestart cache p =
    signal (display (head cache));
    let cache = pop cache in
    promise { nextItem -> just { onNextList cache p } | _ -> nothing }; unit

onNextList : {List Int -> Maybe (Prom (List Int) [InThread]) -> [InThread] Unit}
onNextList cache (just p) =
    if (len cache == 0)
         { let newCache = await p in
           displayRestart newCache nothing }
         { displayRestart cache (just p) }
onNextList xs nothing =
    if (len xs == 3)
       { let resp = promise (ih {(response x) -> just {x} | _ -> nothing}) in
         signal (newData (last xs));
         displayRestart xs (just resp) }
       { displayRestart xs nothing }

client : {List Int -> Maybe (Prom (List Int) [InThread]) -> [InThread] Unit}
client cache p =
    promise (ih { nextItem -> just { onNextList cache p } | _ -> nothing }); unit

serverBody : {Int -> [InThread] Unit}
serverBody x = signal (response (range (x + 1) (x + 10)))

server : {[InThread] Unit}
server! =
    promise (ih { (newData x) -> just { serverBody x; server!} | _ -> nothing }); unit

inNext : {Int -> [Console] Unit}
inNext res = ouint res; print " "

nexter : {[InThread] Unit}
nexter! = inch!; print "*\n"; signal nextItem;
          await (promise (ih { (display res) -> just {inNext res} | _ -> nothing }));
          nexter!
          -- nexter!


----------------------------
-- Callback utilities

to_writeM2 : Prom R [E|RefState]
          -> {S -> (Maybe {[E|RefState] R})}
          -> {S -> (Maybe {[E|RefState] Unit})}
to_writeM2 (prom cell) cb =
    {x -> case (cb x)
         { nothing -> nothing
         | (just susp) ->
             just {case (read cell)
                      { empty -> write cell (done susp!)
                      | (addRes resumption) -> resumption susp!}} }}


print_yield : {String -> [Console, Yield]Unit}
print_yield st = print st; print "\n";
                 sleep 250000;
                 yield!;
                 print_yield st


----------------------------
----- Handling Promises
----------------------------

hdl : {Int -> Ref (Threads S [Console, Yield, RefState])
    -> <Promise S [Console]> Unit
    -> [Yield, Console, RefState] Unit}

hdl thId thrs <promise (ih cb) -> k> =
    -- Create new Prom cell
    let cell = prom (new empty) in
    -- Process callback to convert to general form
    let cbMod = <Console, RefState, Yield>(to_writeM2 cell cb) in

    let cbMaybe = {sig rest -> (case ((cbMod sig))
                                   { nothing -> nothing
                                   | (just susp) -> just { (hdl thId thrs (susp!; <Promise> rest!)) } })} in

    let readthrs = read thrs in
    let queued = <Console, RefState, Yield>(addCb thId (cbMaybe) readthrs) in

    write thrs queued;
    hdl thId thrs (k cell);
    unit


-- So in this case, we want to go to each _thread_ and run the installed callbacks.
hdl thId thrs <signal sig -> thr> =
    let readthrs = read thrs in
    let newThrs = <Console, Yield, RefState>(runThreads sig (readthrs)) in

    let res = {hdl thId thrs (thr unit)} in
    write thrs (<Console, Yield, RefState>(writeThk thId res newThrs));
    res!

hdl thId thrs <await cell -> thr> =
    case (readPid cell)
         { (done x) ->
                 hdl thId thrs (thr x)
         -- thr2 has Fork in ambient, but addRes won't allow that.
         | empty ->
                 writePid cell (addRes thr);
                 hdl thId thrs unit
         | (addRes _) -> print ("Shouldn't happen"); unit}  -- shouldn't happen

hdl thId thrs unit = unit

-- -------------------------------------
-- -- Running

thr1 : {Ref (Threads Feed [Console, Yield, RefState]) -> {[Console, Yield, RefState] Unit}}
thr1 thrs = {hdl 0 thrs (client ([1, 2, 3, 4, 5]) nothing) }

thr2 : {Ref (Threads Feed [Console, Yield, RefState]) -> {[Console, Yield, RefState] Unit}}
thr2 thrs = {hdl 1 thrs (server!) }

thr3 : {Ref (Threads Feed [Console, Yield, RefState]) -> {[Console, Yield, RefState] Unit}}
thr3 thrs = {hdl 2 thrs (nexter!) }

-- All of these RefState adaptors are necessary, unfortunately.
makeThreads : {[RefState] Ref (Threads Feed [Console, Yield, RefState])}
makeThreads! =
    let thrs = new tnil in
    write thrs (tentry 0 (<RefState> (thr1 thrs)) (tq [])
               (tentry 1 (<RefState> (thr2 thrs)) (tq [])
               (tentry 2 (<RefState> (thr3 thrs)) (tq []) tnil)));
    thrs


run : {Ref (Threads Print [Console, Yield, RefState]) -> [Console, RefState]Unit}
run thrs =
    let readthrs = <Console>(read thrs) in
    let runner = <RefState, Console>(lookupThk 0 readthrs) in
    case runner
        { nothing -> unit
        | (just runner) -> (scheduleT (runner!) 0 thrs) };
    unit

hdled : {[Console, RefState]Unit}
hdled! =
    let thrs = <Console> makeThreads! in
    run thrs


main : {[Console, RefState] Unit}
main! = print "Running!\n\n"; hdled!
